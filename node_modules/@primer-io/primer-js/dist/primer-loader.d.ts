export type CardNetwork = {
	displayName: string;
	network: string;
};
export type CardNetworksContext = {
	detectedCardNetwork: CardNetwork | null;
	selectableCardNetworks: CardNetwork[];
	isLoading: boolean;
} | null;
export type SdkState = {
	isSuccessful: boolean;
	isProcessing: boolean;
	error: Error | null;
	isLoading: boolean;
	failure: {
		code: string;
		message: string;
		details?: Record<string, unknown>;
	} | null;
};
export type SdkStateContext = SdkState | null;
/**
 * A CSSResult or native CSSStyleSheet.
 *
 * In browsers that support constructible CSS style sheets, CSSStyleSheet
 * object can be used for styling along side CSSResult from the `css`
 * template tag.
 */
export type CSSResultOrNative = CSSResult | CSSStyleSheet;
export type CSSResultArray = Array<CSSResultOrNative | CSSResultArray>;
/**
 * A single CSSResult, CSSStyleSheet, or an array or nested arrays of those.
 */
export type CSSResultGroup = CSSResultOrNative | CSSResultArray;
declare class CSSResult {
	["_$cssResult$"]: boolean;
	readonly cssText: string;
	private _styleSheet?;
	private _strings;
	private constructor();
	get styleSheet(): CSSStyleSheet | undefined;
	toString(): string;
}
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
/**
 * An object that can host Reactive Controllers and call their lifecycle
 * callbacks.
 */
export interface ReactiveControllerHost {
	/**
	 * Adds a controller to the host, which sets up the controller's lifecycle
	 * methods to be called with the host's lifecycle.
	 */
	addController(controller: ReactiveController): void;
	/**
	 * Removes a controller from the host.
	 */
	removeController(controller: ReactiveController): void;
	/**
	 * Requests a host update which is processed asynchronously. The update can
	 * be waited on via the `updateComplete` property.
	 */
	requestUpdate(): void;
	/**
	 * Returns a Promise that resolves when the host has completed updating.
	 * The Promise value is a boolean that is `true` if the element completed the
	 * update without triggering another update. The Promise result is `false` if
	 * a property was set inside `updated()`. If the Promise is rejected, an
	 * exception was thrown during the update.
	 *
	 * @return A promise of a boolean that indicates if the update resolved
	 *     without triggering another update.
	 */
	readonly updateComplete: Promise<boolean>;
}
/**
 * A Reactive Controller is an object that enables sub-component code
 * organization and reuse by aggregating the state, behavior, and lifecycle
 * hooks related to a single feature.
 *
 * Controllers are added to a host component, or other object that implements
 * the `ReactiveControllerHost` interface, via the `addController()` method.
 * They can hook their host components's lifecycle by implementing one or more
 * of the lifecycle callbacks, or initiate an update of the host component by
 * calling `requestUpdate()` on the host.
 */
export interface ReactiveController {
	/**
	 * Called when the host is connected to the component tree. For custom
	 * element hosts, this corresponds to the `connectedCallback()` lifecycle,
	 * which is only called when the component is connected to the document.
	 */
	hostConnected?(): void;
	/**
	 * Called when the host is disconnected from the component tree. For custom
	 * element hosts, this corresponds to the `disconnectedCallback()` lifecycle,
	 * which is called the host or an ancestor component is disconnected from the
	 * document.
	 */
	hostDisconnected?(): void;
	/**
	 * Called during the client-side host update, just before the host calls
	 * its own update.
	 *
	 * Code in `update()` can depend on the DOM as it is not called in
	 * server-side rendering.
	 */
	hostUpdate?(): void;
	/**
	 * Called after a host update, just before the host calls firstUpdated and
	 * updated. It is not called in server-side rendering.
	 *
	 */
	hostUpdated?(): void;
}
/**
 * Converts property values to and from attribute values.
 */
export interface ComplexAttributeConverter<Type = unknown, TypeHint = unknown> {
	/**
	 * Called to convert an attribute value to a property
	 * value.
	 */
	fromAttribute?(value: string | null, type?: TypeHint): Type;
	/**
	 * Called to convert a property value to an attribute
	 * value.
	 *
	 * It returns unknown instead of string, to be compatible with
	 * https://github.com/WICG/trusted-types (and similar efforts).
	 */
	toAttribute?(value: Type, type?: TypeHint): unknown;
}
export type AttributeConverter<Type = unknown, TypeHint = unknown> = ComplexAttributeConverter<Type> | ((value: string | null, type?: TypeHint) => Type);
/**
 * Defines options for a property accessor.
 */
export interface PropertyDeclaration<Type = unknown, TypeHint = unknown> {
	/**
	 * When set to `true`, indicates the property is internal private state. The
	 * property should not be set by users. When using TypeScript, this property
	 * should be marked as `private` or `protected`, and it is also a common
	 * practice to use a leading `_` in the name. The property is not added to
	 * `observedAttributes`.
	 */
	readonly state?: boolean;
	/**
	 * Indicates how and whether the property becomes an observed attribute.
	 * If the value is `false`, the property is not added to `observedAttributes`.
	 * If true or absent, the lowercased property name is observed (e.g. `fooBar`
	 * becomes `foobar`). If a string, the string value is observed (e.g
	 * `attribute: 'foo-bar'`).
	 */
	readonly attribute?: boolean | string;
	/**
	 * Indicates the type of the property. This is used only as a hint for the
	 * `converter` to determine how to convert the attribute
	 * to/from a property.
	 */
	readonly type?: TypeHint;
	/**
	 * Indicates how to convert the attribute to/from a property. If this value
	 * is a function, it is used to convert the attribute value a the property
	 * value. If it's an object, it can have keys for `fromAttribute` and
	 * `toAttribute`. If no `toAttribute` function is provided and
	 * `reflect` is set to `true`, the property value is set directly to the
	 * attribute. A default `converter` is used if none is provided; it supports
	 * `Boolean`, `String`, `Number`, `Object`, and `Array`. Note,
	 * when a property changes and the converter is used to update the attribute,
	 * the property is never updated again as a result of the attribute changing,
	 * and vice versa.
	 */
	readonly converter?: AttributeConverter<Type, TypeHint>;
	/**
	 * Indicates if the property should reflect to an attribute.
	 * If `true`, when the property is set, the attribute is set using the
	 * attribute name determined according to the rules for the `attribute`
	 * property option and the value of the property converted using the rules
	 * from the `converter` property option.
	 */
	readonly reflect?: boolean;
	/**
	 * A function that indicates if a property should be considered changed when
	 * it is set. The function should take the `newValue` and `oldValue` and
	 * return `true` if an update should be requested.
	 */
	hasChanged?(value: Type, oldValue: Type): boolean;
	/**
	 * Indicates whether an accessor will be created for this property. By
	 * default, an accessor will be generated for this property that requests an
	 * update when set. If this flag is `true`, no accessor will be created, and
	 * it will be the user's responsibility to call
	 * `this.requestUpdate(propertyName, oldValue)` to request an update when
	 * the property changes.
	 */
	readonly noAccessor?: boolean;
}
/**
 * Map of properties to PropertyDeclaration options. For each property an
 * accessor is made, and the property is processed according to the
 * PropertyDeclaration options.
 */
export interface PropertyDeclarations {
	readonly [key: string]: PropertyDeclaration;
}
export type PropertyDeclarationMap = Map<PropertyKey, PropertyDeclaration>;
/**
 * A Map of property keys to values.
 *
 * Takes an optional type parameter T, which when specified as a non-any,
 * non-unknown type, will make the Map more strongly-typed, associating the map
 * keys with their corresponding value type on T.
 *
 * Use `PropertyValues<this>` when overriding ReactiveElement.update() and
 * other lifecycle methods in order to get stronger type-checking on keys
 * and values.
 */
export type PropertyValues<T = any> = T extends object ? PropertyValueMap<T> : Map<PropertyKey, unknown>;
/**
 * Do not use, instead prefer {@linkcode PropertyValues}.
 */
export interface PropertyValueMap<T> extends Map<PropertyKey, unknown> {
	get<K extends keyof T>(k: K): T[K] | undefined;
	set<K extends keyof T>(key: K, value: T[K]): this;
	has<K extends keyof T>(k: K): boolean;
	delete<K extends keyof T>(k: K): boolean;
}
/**
 * A string representing one of the supported dev mode warning categories.
 */
export type WarningKind = "change-in-update" | "migration" | "async-perform-update";
export type Initializer = (element: ReactiveElement) => void;
declare global {
	interface SymbolConstructor {
		readonly metadata: unique symbol;
	}
}
declare global {
	var litPropertyMetadata: WeakMap<object, Map<PropertyKey, PropertyDeclaration>>;
}
declare abstract class ReactiveElement extends HTMLElement implements ReactiveControllerHost {
	/**
	 * Read or set all the enabled warning categories for this class.
	 *
	 * This property is only used in development builds.
	 *
	 * @nocollapse
	 * @category dev-mode
	 */
	static enabledWarnings?: WarningKind[];
	/**
	 * Enable the given warning category for this class.
	 *
	 * This method only exists in development builds, so it should be accessed
	 * with a guard like:
	 *
	 * ```ts
	 * // Enable for all ReactiveElement subclasses
	 * ReactiveElement.enableWarning?.('migration');
	 *
	 * // Enable for only MyElement and subclasses
	 * MyElement.enableWarning?.('migration');
	 * ```
	 *
	 * @nocollapse
	 * @category dev-mode
	 */
	static enableWarning?: (warningKind: WarningKind) => void;
	/**
	 * Disable the given warning category for this class.
	 *
	 * This method only exists in development builds, so it should be accessed
	 * with a guard like:
	 *
	 * ```ts
	 * // Disable for all ReactiveElement subclasses
	 * ReactiveElement.disableWarning?.('migration');
	 *
	 * // Disable for only MyElement and subclasses
	 * MyElement.disableWarning?.('migration');
	 * ```
	 *
	 * @nocollapse
	 * @category dev-mode
	 */
	static disableWarning?: (warningKind: WarningKind) => void;
	/**
	 * Adds an initializer function to the class that is called during instance
	 * construction.
	 *
	 * This is useful for code that runs against a `ReactiveElement`
	 * subclass, such as a decorator, that needs to do work for each
	 * instance, such as setting up a `ReactiveController`.
	 *
	 * ```ts
	 * const myDecorator = (target: typeof ReactiveElement, key: string) => {
	 *   target.addInitializer((instance: ReactiveElement) => {
	 *     // This is run during construction of the element
	 *     new MyController(instance);
	 *   });
	 * }
	 * ```
	 *
	 * Decorating a field will then cause each instance to run an initializer
	 * that adds a controller:
	 *
	 * ```ts
	 * class MyElement extends LitElement {
	 *   @myDecorator foo;
	 * }
	 * ```
	 *
	 * Initializers are stored per-constructor. Adding an initializer to a
	 * subclass does not add it to a superclass. Since initializers are run in
	 * constructors, initializers will run in order of the class hierarchy,
	 * starting with superclasses and progressing to the instance's class.
	 *
	 * @nocollapse
	 */
	static addInitializer(initializer: Initializer): void;
	static _initializers?: Initializer[];
	/**
	 * Maps attribute names to properties; for example `foobar` attribute to
	 * `fooBar` property. Created lazily on user subclasses when finalizing the
	 * class.
	 * @nocollapse
	 */
	private static __attributeToPropertyMap;
	/**
	 * Marks class as having been finalized, which includes creating properties
	 * from `static properties`, but does *not* include all properties created
	 * from decorators.
	 * @nocollapse
	 */
	protected static finalized: true | undefined;
	/**
	 * Memoized list of all element properties, including any superclass
	 * properties. Created lazily on user subclasses when finalizing the class.
	 *
	 * @nocollapse
	 * @category properties
	 */
	static elementProperties: PropertyDeclarationMap;
	/**
	 * User-supplied object that maps property names to `PropertyDeclaration`
	 * objects containing options for configuring reactive properties. When
	 * a reactive property is set the element will update and render.
	 *
	 * By default properties are public fields, and as such, they should be
	 * considered as primarily settable by element users, either via attribute or
	 * the property itself.
	 *
	 * Generally, properties that are changed by the element should be private or
	 * protected fields and should use the `state: true` option. Properties
	 * marked as `state` do not reflect from the corresponding attribute
	 *
	 * However, sometimes element code does need to set a public property. This
	 * should typically only be done in response to user interaction, and an event
	 * should be fired informing the user; for example, a checkbox sets its
	 * `checked` property when clicked and fires a `changed` event. Mutating
	 * public properties should typically not be done for non-primitive (object or
	 * array) properties. In other cases when an element needs to manage state, a
	 * private property set with the `state: true` option should be used. When
	 * needed, state properties can be initialized via public properties to
	 * facilitate complex interactions.
	 * @nocollapse
	 * @category properties
	 */
	static properties: PropertyDeclarations;
	/**
	 * Memoized list of all element styles.
	 * Created lazily on user subclasses when finalizing the class.
	 * @nocollapse
	 * @category styles
	 */
	static elementStyles: Array<CSSResultOrNative>;
	/**
	 * Array of styles to apply to the element. The styles should be defined
	 * using the {@linkcode css} tag function, via constructible stylesheets, or
	 * imported from native CSS module scripts.
	 *
	 * Note on Content Security Policy:
	 *
	 * Element styles are implemented with `<style>` tags when the browser doesn't
	 * support adopted StyleSheets. To use such `<style>` tags with the style-src
	 * CSP directive, the style-src value must either include 'unsafe-inline' or
	 * `nonce-<base64-value>` with `<base64-value>` replaced be a server-generated
	 * nonce.
	 *
	 * To provide a nonce to use on generated `<style>` elements, set
	 * `window.litNonce` to a server-generated nonce in your page's HTML, before
	 * loading application code:
	 *
	 * ```html
	 * <script>
	 *   // Generated and unique per request:
	 *   window.litNonce = 'a1b2c3d4';
	 * </script>
	 * ```
	 * @nocollapse
	 * @category styles
	 */
	static styles?: CSSResultGroup;
	/**
	 * Returns a list of attributes corresponding to the registered properties.
	 * @nocollapse
	 * @category attributes
	 */
	static get observedAttributes(): string[];
	private __instanceProperties?;
	/**
	 * Creates a property accessor on the element prototype if one does not exist
	 * and stores a {@linkcode PropertyDeclaration} for the property with the
	 * given options. The property setter calls the property's `hasChanged`
	 * property option or uses a strict identity check to determine whether or not
	 * to request an update.
	 *
	 * This method may be overridden to customize properties; however,
	 * when doing so, it's important to call `super.createProperty` to ensure
	 * the property is setup correctly. This method calls
	 * `getPropertyDescriptor` internally to get a descriptor to install.
	 * To customize what properties do when they are get or set, override
	 * `getPropertyDescriptor`. To customize the options for a property,
	 * implement `createProperty` like this:
	 *
	 * ```ts
	 * static createProperty(name, options) {
	 *   options = Object.assign(options, {myOption: true});
	 *   super.createProperty(name, options);
	 * }
	 * ```
	 *
	 * @nocollapse
	 * @category properties
	 */
	static createProperty(name: PropertyKey, options?: PropertyDeclaration): void;
	/**
	 * Returns a property descriptor to be defined on the given named property.
	 * If no descriptor is returned, the property will not become an accessor.
	 * For example,
	 *
	 * ```ts
	 * class MyElement extends LitElement {
	 *   static getPropertyDescriptor(name, key, options) {
	 *     const defaultDescriptor =
	 *         super.getPropertyDescriptor(name, key, options);
	 *     const setter = defaultDescriptor.set;
	 *     return {
	 *       get: defaultDescriptor.get,
	 *       set(value) {
	 *         setter.call(this, value);
	 *         // custom action.
	 *       },
	 *       configurable: true,
	 *       enumerable: true
	 *     }
	 *   }
	 * }
	 * ```
	 *
	 * @nocollapse
	 * @category properties
	 */
	protected static getPropertyDescriptor(name: PropertyKey, key: string | symbol, options: PropertyDeclaration): PropertyDescriptor | undefined;
	/**
	 * Returns the property options associated with the given property.
	 * These options are defined with a `PropertyDeclaration` via the `properties`
	 * object or the `@property` decorator and are registered in
	 * `createProperty(...)`.
	 *
	 * Note, this method should be considered "final" and not overridden. To
	 * customize the options for a given property, override
	 * {@linkcode createProperty}.
	 *
	 * @nocollapse
	 * @final
	 * @category properties
	 */
	static getPropertyOptions(name: PropertyKey): PropertyDeclaration<unknown, unknown>;
	static [Symbol.metadata]: object & Record<PropertyKey, unknown>;
	/**
	 * Initializes static own properties of the class used in bookkeeping
	 * for element properties, initializers, etc.
	 *
	 * Can be called multiple times by code that needs to ensure these
	 * properties exist before using them.
	 *
	 * This method ensures the superclass is finalized so that inherited
	 * property metadata can be copied down.
	 * @nocollapse
	 */
	private static __prepare;
	/**
	 * Finishes setting up the class so that it's ready to be registered
	 * as a custom element and instantiated.
	 *
	 * This method is called by the ReactiveElement.observedAttributes getter.
	 * If you override the observedAttributes getter, you must either call
	 * super.observedAttributes to trigger finalization, or call finalize()
	 * yourself.
	 *
	 * @nocollapse
	 */
	protected static finalize(): void;
	/**
	 * Options used when calling `attachShadow`. Set this property to customize
	 * the options for the shadowRoot; for example, to create a closed
	 * shadowRoot: `{mode: 'closed'}`.
	 *
	 * Note, these options are used in `createRenderRoot`. If this method
	 * is customized, options should be respected if possible.
	 * @nocollapse
	 * @category rendering
	 */
	static shadowRootOptions: ShadowRootInit;
	/**
	 * Takes the styles the user supplied via the `static styles` property and
	 * returns the array of styles to apply to the element.
	 * Override this method to integrate into a style management system.
	 *
	 * Styles are deduplicated preserving the _last_ instance in the list. This
	 * is a performance optimization to avoid duplicated styles that can occur
	 * especially when composing via subclassing. The last item is kept to try
	 * to preserve the cascade order with the assumption that it's most important
	 * that last added styles override previous styles.
	 *
	 * @nocollapse
	 * @category styles
	 */
	protected static finalizeStyles(styles?: CSSResultGroup): Array<CSSResultOrNative>;
	/**
	 * Node or ShadowRoot into which element DOM should be rendered. Defaults
	 * to an open shadowRoot.
	 * @category rendering
	 */
	readonly renderRoot: HTMLElement | DocumentFragment;
	/**
	 * Returns the property name for the given attribute `name`.
	 * @nocollapse
	 */
	private static __attributeNameForProperty;
	private __updatePromise;
	/**
	 * True if there is a pending update as a result of calling `requestUpdate()`.
	 * Should only be read.
	 * @category updates
	 */
	isUpdatePending: boolean;
	/**
	 * Is set to `true` after the first update. The element code cannot assume
	 * that `renderRoot` exists before the element `hasUpdated`.
	 * @category updates
	 */
	hasUpdated: boolean;
	/**
	 * Properties that should be reflected when updated.
	 */
	private __reflectingProperties?;
	/**
	 * Name of currently reflecting property
	 */
	private __reflectingProperty;
	/**
	 * Set of controllers.
	 */
	private __controllers?;
	constructor();
	/**
	 * Internal only override point for customizing work done when elements
	 * are constructed.
	 */
	private __initialize;
	/**
	 * Registers a `ReactiveController` to participate in the element's reactive
	 * update cycle. The element automatically calls into any registered
	 * controllers during its lifecycle callbacks.
	 *
	 * If the element is connected when `addController()` is called, the
	 * controller's `hostConnected()` callback will be immediately called.
	 * @category controllers
	 */
	addController(controller: ReactiveController): void;
	/**
	 * Removes a `ReactiveController` from the element.
	 * @category controllers
	 */
	removeController(controller: ReactiveController): void;
	/**
	 * Fixes any properties set on the instance before upgrade time.
	 * Otherwise these would shadow the accessor and break these properties.
	 * The properties are stored in a Map which is played back after the
	 * constructor runs. Note, on very old versions of Safari (<=9) or Chrome
	 * (<=41), properties created for native platform properties like (`id` or
	 * `name`) may not have default values set in the element constructor. On
	 * these browsers native properties appear on instances and therefore their
	 * default value will overwrite any element default (e.g. if the element sets
	 * this.id = 'id' in the constructor, the 'id' will become '' since this is
	 * the native platform default).
	 */
	private __saveInstanceProperties;
	/**
	 * Returns the node into which the element should render and by default
	 * creates and returns an open shadowRoot. Implement to customize where the
	 * element's DOM is rendered. For example, to render into the element's
	 * childNodes, return `this`.
	 *
	 * @return Returns a node into which to render.
	 * @category rendering
	 */
	protected createRenderRoot(): HTMLElement | DocumentFragment;
	/**
	 * On first connection, creates the element's renderRoot, sets up
	 * element styling, and enables updating.
	 * @category lifecycle
	 */
	connectedCallback(): void;
	/**
	 * Note, this method should be considered final and not overridden. It is
	 * overridden on the element instance with a function that triggers the first
	 * update.
	 * @category updates
	 */
	protected enableUpdating(_requestedUpdate: boolean): void;
	/**
	 * Allows for `super.disconnectedCallback()` in extensions while
	 * reserving the possibility of making non-breaking feature additions
	 * when disconnecting at some point in the future.
	 * @category lifecycle
	 */
	disconnectedCallback(): void;
	/**
	 * Synchronizes property values when attributes change.
	 *
	 * Specifically, when an attribute is set, the corresponding property is set.
	 * You should rarely need to implement this callback. If this method is
	 * overridden, `super.attributeChangedCallback(name, _old, value)` must be
	 * called.
	 *
	 * See [using the lifecycle callbacks](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements#using_the_lifecycle_callbacks)
	 * on MDN for more information about the `attributeChangedCallback`.
	 * @category attributes
	 */
	attributeChangedCallback(name: string, _old: string | null, value: string | null): void;
	private __propertyToAttribute;
	/**
	 * Requests an update which is processed asynchronously. This should be called
	 * when an element should update based on some state not triggered by setting
	 * a reactive property. In this case, pass no arguments. It should also be
	 * called when manually implementing a property setter. In this case, pass the
	 * property `name` and `oldValue` to ensure that any configured property
	 * options are honored.
	 *
	 * @param name name of requesting property
	 * @param oldValue old value of requesting property
	 * @param options property options to use instead of the previously
	 *     configured options
	 * @category updates
	 */
	requestUpdate(name?: PropertyKey, oldValue?: unknown, options?: PropertyDeclaration): void;
	/**
	 * Sets up the element to asynchronously update.
	 */
	private __enqueueUpdate;
	/**
	 * Schedules an element update. You can override this method to change the
	 * timing of updates by returning a Promise. The update will await the
	 * returned Promise, and you should resolve the Promise to allow the update
	 * to proceed. If this method is overridden, `super.scheduleUpdate()`
	 * must be called.
	 *
	 * For instance, to schedule updates to occur just before the next frame:
	 *
	 * ```ts
	 * override protected async scheduleUpdate(): Promise<unknown> {
	 *   await new Promise((resolve) => requestAnimationFrame(() => resolve()));
	 *   super.scheduleUpdate();
	 * }
	 * ```
	 * @category updates
	 */
	protected scheduleUpdate(): void | Promise<unknown>;
	/**
	 * Performs an element update. Note, if an exception is thrown during the
	 * update, `firstUpdated` and `updated` will not be called.
	 *
	 * Call `performUpdate()` to immediately process a pending update. This should
	 * generally not be needed, but it can be done in rare cases when you need to
	 * update synchronously.
	 *
	 * @category updates
	 */
	protected performUpdate(): void;
	/**
	 * Invoked before `update()` to compute values needed during the update.
	 *
	 * Implement `willUpdate` to compute property values that depend on other
	 * properties and are used in the rest of the update process.
	 *
	 * ```ts
	 * willUpdate(changedProperties) {
	 *   // only need to check changed properties for an expensive computation.
	 *   if (changedProperties.has('firstName') || changedProperties.has('lastName')) {
	 *     this.sha = computeSHA(`${this.firstName} ${this.lastName}`);
	 *   }
	 * }
	 *
	 * render() {
	 *   return html`SHA: ${this.sha}`;
	 * }
	 * ```
	 *
	 * @category updates
	 */
	protected willUpdate(_changedProperties: PropertyValues): void;
	private __markUpdated;
	/**
	 * Returns a Promise that resolves when the element has completed updating.
	 * The Promise value is a boolean that is `true` if the element completed the
	 * update without triggering another update. The Promise result is `false` if
	 * a property was set inside `updated()`. If the Promise is rejected, an
	 * exception was thrown during the update.
	 *
	 * To await additional asynchronous work, override the `getUpdateComplete`
	 * method. For example, it is sometimes useful to await a rendered element
	 * before fulfilling this Promise. To do this, first await
	 * `super.getUpdateComplete()`, then any subsequent state.
	 *
	 * @return A promise of a boolean that resolves to true if the update completed
	 *     without triggering another update.
	 * @category updates
	 */
	get updateComplete(): Promise<boolean>;
	/**
	 * Override point for the `updateComplete` promise.
	 *
	 * It is not safe to override the `updateComplete` getter directly due to a
	 * limitation in TypeScript which means it is not possible to call a
	 * superclass getter (e.g. `super.updateComplete.then(...)`) when the target
	 * language is ES5 (https://github.com/microsoft/TypeScript/issues/338).
	 * This method should be overridden instead. For example:
	 *
	 * ```ts
	 * class MyElement extends LitElement {
	 *   override async getUpdateComplete() {
	 *     const result = await super.getUpdateComplete();
	 *     await this._myChild.updateComplete;
	 *     return result;
	 *   }
	 * }
	 * ```
	 *
	 * @return A promise of a boolean that resolves to true if the update completed
	 *     without triggering another update.
	 * @category updates
	 */
	protected getUpdateComplete(): Promise<boolean>;
	/**
	 * Controls whether or not `update()` should be called when the element requests
	 * an update. By default, this method always returns `true`, but this can be
	 * customized to control when to update.
	 *
	 * @param _changedProperties Map of changed properties with old values
	 * @category updates
	 */
	protected shouldUpdate(_changedProperties: PropertyValues): boolean;
	/**
	 * Updates the element. This method reflects property values to attributes.
	 * It can be overridden to render and keep updated element DOM.
	 * Setting properties inside this method will *not* trigger
	 * another update.
	 *
	 * @param _changedProperties Map of changed properties with old values
	 * @category updates
	 */
	protected update(_changedProperties: PropertyValues): void;
	/**
	 * Invoked whenever the element is updated. Implement to perform
	 * post-updating tasks via DOM APIs, for example, focusing an element.
	 *
	 * Setting properties inside this method will trigger the element to update
	 * again after this update cycle completes.
	 *
	 * @param _changedProperties Map of changed properties with old values
	 * @category updates
	 */
	protected updated(_changedProperties: PropertyValues): void;
	/**
	 * Invoked when the element is first updated. Implement to perform one time
	 * work on the element after update.
	 *
	 * ```ts
	 * firstUpdated() {
	 *   this.renderRoot.getElementById('my-text-area').focus();
	 * }
	 * ```
	 *
	 * Setting properties inside this method will trigger the element to update
	 * again after this update cycle completes.
	 *
	 * @param _changedProperties Map of changed properties with old values
	 * @category updates
	 */
	protected firstUpdated(_changedProperties: PropertyValues): void;
}
declare const HTML_RESULT = 1;
declare const SVG_RESULT = 2;
declare const MATHML_RESULT = 3;
export type ResultType = typeof HTML_RESULT | typeof SVG_RESULT | typeof MATHML_RESULT;
/**
 * The return type of the template tag functions, {@linkcode html} and
 * {@linkcode svg} when it hasn't been compiled by @lit-labs/compiler.
 *
 * A `TemplateResult` object holds all the information about a template
 * expression required to render it: the template strings, expression values,
 * and type of template (html or svg).
 *
 * `TemplateResult` objects do not create any DOM on their own. To create or
 * update DOM you need to render the `TemplateResult`. See
 * [Rendering](https://lit.dev/docs/components/rendering) for more information.
 *
 */
export type UncompiledTemplateResult<T extends ResultType = ResultType> = {
	["_$litType$"]: T;
	strings: TemplateStringsArray;
	values: unknown[];
};
/**
 * The return type of the template tag functions, {@linkcode html} and
 * {@linkcode svg}.
 *
 * A `TemplateResult` object holds all the information about a template
 * expression required to render it: the template strings, expression values,
 * and type of template (html or svg).
 *
 * `TemplateResult` objects do not create any DOM on their own. To create or
 * update DOM you need to render the `TemplateResult`. See
 * [Rendering](https://lit.dev/docs/components/rendering) for more information.
 *
 * In Lit 4, this type will be an alias of
 * MaybeCompiledTemplateResult, so that code will get type errors if it assumes
 * that Lit templates are not compiled. When deliberately working with only
 * one, use either {@linkcode CompiledTemplateResult} or
 * {@linkcode UncompiledTemplateResult} explicitly.
 */
export type TemplateResult<T extends ResultType = ResultType> = UncompiledTemplateResult<T>;
export type SVGTemplateResult = TemplateResult<typeof SVG_RESULT>;
declare const nothing: unique symbol;
/**
 * Object specifying options for controlling lit-html rendering. Note that
 * while `render` may be called multiple times on the same `container` (and
 * `renderBefore` reference node) to efficiently update the rendered content,
 * only the options passed in during the first render are respected during
 * the lifetime of renders to that unique `container` + `renderBefore`
 * combination.
 */
export interface RenderOptions {
	/**
	 * An object to use as the `this` value for event listeners. It's often
	 * useful to set this to the host component rendering a template.
	 */
	host?: object;
	/**
	 * A DOM node before which to render content in the container.
	 */
	renderBefore?: ChildNode | null;
	/**
	 * Node used for cloning the template (`importNode` will be called on this
	 * node). This controls the `ownerDocument` of the rendered DOM, along with
	 * any inherited context. Defaults to the global `document`.
	 */
	creationScope?: {
		importNode(node: Node, deep?: boolean): Node;
	};
	/**
	 * The initial connected state for the top-level part being rendered. If no
	 * `isConnected` option is set, `AsyncDirective`s will be connected by
	 * default. Set to `false` if the initial render occurs in a disconnected tree
	 * and `AsyncDirective`s should see `isConnected === false` for their initial
	 * render. The `part.setConnected()` method must be used subsequent to initial
	 * render to change the connected state of the part.
	 */
	isConnected?: boolean;
}
/**
 * @description Defines the API version that the SDK should use.
 * - `"legacy"`: Uses the older API version with existing behaviors.
 * - `"2.4"`: Uses the new API version with updated functionalities.
 *
 * If this value is not set, the SDK will default to the predefined version,
 * ensuring backward compatibility.
 */
export type APIVersionOption = "legacy" | "2.4";
declare enum ImplementationType {
	WEB_REDIRECT = "WEB_REDIRECT",
	NATIVE_SDK = "NATIVE_SDK"
}
declare enum ProductType {
	DIGITAL = "DIGITAL",
	PHYSICAL = "PHYSICAL",
	SHIPPING_FEE = "SHIPPING_FEE"
}
export interface ClientSessionLineItem {
	amount: number;
	description: string;
	discountAmount?: number;
	itemId: string;
	name?: string;
	productType?: ProductType;
	quantity: number;
	taxAmount?: number;
	taxCode?: string;
}
export interface ClientSessionShipping {
	amount: number;
	methodId?: string;
	methodName?: string;
	methodDescription?: string;
}
export interface ClientSessionFeeItem {
	type?: string;
	description?: string;
	amount: number;
}
export interface ClientSessionAddress {
	firstName?: string;
	lastName?: string;
	addressLine1?: string;
	addressLine2?: string;
	city?: string;
	state?: string;
	countryCode?: string;
	postalCode?: string;
}
export interface ClientSession {
	orderId?: string;
	currencyCode?: string;
	lineItems?: ClientSessionLineItem[];
	totalAmount?: number;
	customerId?: string;
	orderDetails?: {
		countryCode?: string;
		shipping?: ClientSessionShipping;
		fees?: ClientSessionFeeItem[];
	};
	customer?: {
		emailAddress?: string;
		mobileNumber?: string;
		firstName?: string;
		lastName?: string;
		billingAddress?: ClientSessionAddress;
		shippingAddress?: ClientSessionAddress;
		taxId?: string;
		nationalDocumentId?: string;
	};
	paymentMethod?: {
		options?: Record<string, any>;
		orderedAllowedCardNetworks?: string[];
		vaultOnSuccess?: boolean;
	};
}
export interface PaymentMethodDisplayMetadata {
	button: {
		backgroundColor: BackgroundColor;
		borderColor: BorderColor;
		borderWidth: BorderWidth;
		cornerRadius: number;
		iconPositionRelativeToText?: "START" | "END";
		iconUrl: IconUrl;
		text?: string;
		textColor?: TextColor;
	};
	overlay: {
		logo: IconUrl;
		backgroundColor: BackgroundColor;
	};
	popup: {
		width: number;
		height: number;
	};
}
export interface BackgroundColor {
	colored: string;
	dark: string;
	light: string;
}
export interface BorderColor {
	dark: string;
	light: string;
}
export interface BorderWidth {
	colored: number;
	dark: number;
	light: number;
}
export interface IconUrl {
	colored: string;
	dark: string;
	light: string;
}
export interface TextColor {
	dark: string;
	light: string;
}
export interface PaymentMethodConfig {
	id: string;
	type: PaymentMethodType;
	name: string;
	implementationType: ImplementationType;
	displayMetadata: PaymentMethodDisplayMetadata;
	options: {
		captureVaultedCardCvv?: boolean;
		clientId?: string;
		threeDSecureToken?: string;
		threeDSecureInitUrl?: string;
		threeDSecureProvider?: string;
		threeDSecureEnabled?: boolean;
	};
	forceRedirect?: boolean;
}
export type GoatBrand = {
	assets: {
		icon: string;
	};
	colors: {
		background: string;
		main: string;
	};
	description: string | null;
	is_primer_app: boolean;
	name: string;
	website: string | null;
};
export type GoatBrandWithCdn = GoatBrand & {
	/**
	 * The full CDN URL that can be used directly in applications
	 */
	goatCdnUrl: string;
};
declare const PaymentInstrumentType: {
	readonly WORLDPAY_IDEAL: "WORLDPAY_IDEAL";
	readonly AUTOMATED_CLEARING_HOUSE: "AUTOMATED_CLEARING_HOUSE";
	readonly ADYEN_KLARNA: "ADYEN_KLARNA";
	readonly ADYEN_BANCONTACT_CARD: "ADYEN_BANCONTACT_CARD";
	readonly PAY_NL_KAARTDIRECT: "PAY_NL_KAARTDIRECT";
	readonly ADYEN_EPS: "ADYEN_EPS";
	readonly ADYEN_BANCONTACT_PAYCONIQ: "ADYEN_BANCONTACT_PAYCONIQ";
	readonly OMISE_PROMPTPAY: "OMISE_PROMPTPAY";
	readonly OMISE_TRUEMONEY: "OMISE_TRUEMONEY";
	readonly ADYEN_MULTIBANCO: "ADYEN_MULTIBANCO";
	readonly PACYPAY_WECHAT: "PACYPAY_WECHAT";
	readonly PACYPAY_ALIPAY: "PACYPAY_ALIPAY";
	readonly ADYEN_MBWAY: "ADYEN_MBWAY";
	readonly XENDIT_DANA: "XENDIT_DANA";
	readonly XENDIT_SHOPEEPAY: "XENDIT_SHOPEEPAY";
	readonly ADYEN_PAYSHOP: "ADYEN_PAYSHOP";
	readonly ADYEN_PAYTRAIL: "ADYEN_PAYTRAIL";
	readonly CLEARPAY: "CLEARPAY";
	readonly RAPYD_FAST: "RAPYD_FAST";
	readonly RAPYD_PROMPTPAY: "RAPYD_PROMPTPAY";
	readonly RAPYD_GCASH: "RAPYD_GCASH";
	readonly RAPYD_POLI: "RAPYD_POLI";
	readonly RAPYD_GRABPAY: "RAPYD_GRABPAY";
	readonly PRIMER_PAYPAL: "PRIMER_PAYPAL";
	readonly TWOC2P: "TWOC2P";
	readonly NETS: "NETS";
	readonly STRIPE_ACH: "STRIPE_ACH";
	readonly STRIPE_GIROPAY: "STRIPE_GIROPAY";
	readonly MOLLIE_GIROPAY: "MOLLIE_GIROPAY";
	readonly MOLLIE_EPS: "MOLLIE_EPS";
	readonly PAY_NL_EPS: "PAY_NL_EPS";
	readonly PAY_NL_P24: "PAY_NL_P24";
	readonly MOLLIE_P24: "MOLLIE_P24";
	readonly MOLLIE_SOFORT: "MOLLIE_SOFORT";
	readonly COINBASE: "COINBASE";
	readonly OPENNODE: "OPENNODE";
	readonly MOLLIE_GIFT_CARD: "MOLLIE_GIFTCARD";
	readonly XFERS_PAYNOW: "XFERS_PAYNOW";
	readonly CARD: "PAYMENT_CARD";
	readonly APPLE_PAY: "APPLE_PAY";
	readonly GOOGLE_PAY: "GOOGLE_PAY";
	readonly PAYPAL: "PAYPAL_ORDER";
	readonly PAYPAL_VAULTED: "PAYPAL_BILLING_AGREEMENT";
	readonly GO_CARDLESS: "GOCARDLESS";
	readonly PAY_NL_IDEAL: "PAY_NL_IDEAL";
	readonly PAY_NL_SOFORT_BANKING: "PAY_NL_SOFORT_BANKING";
	readonly PAY_NL_BANCONTACT: "PAY_NL_BANCONTACT";
	readonly PAY_NL_PAYPAL: "PAY_NL_PAYPAL";
	readonly PAY_NL_CREDIT_TRANSFER: "PAY_NL_CREDIT_TRANSFER";
	readonly PAY_NL_DIRECT_DEBIT: "PAY_NL_DIRECT_DEBIT";
	readonly PAY_NL_GIROPAY: "PAY_NL_GIROPAY";
	readonly PAY_NL_PAYCONIQ: "PAY_NL_PAYCONIQ";
	readonly HOOLAH: "HOOLAH";
	readonly ADYEN_BLIK: "ADYEN_BLIK";
	readonly ADYEN_VIPPS: "ADYEN_VIPPS";
	readonly ADYEN_GIROPAY: "ADYEN_GIROPAY";
	readonly ADYEN_SOFORT: "ADYEN_SOFORT";
	readonly ADYEN_IDEAL: "ADYEN_IDEAL";
	readonly ADYEN_TRUSTLY: "ADYEN_TRUSTLY";
	readonly ADYEN_ALIPAY: "ADYEN_ALIPAY";
	readonly ADYEN_TWINT: "ADYEN_TWINT";
	readonly ADYEN_MOBILEPAY: "ADYEN_MOBILEPAY";
	readonly MOLLIE_BANCONTACT: "MOLLIE_BANCONTACT";
	readonly MOLLIE_IDEAL: "MOLLIE_IDEAL";
	readonly BUCKAROO_GIROPAY: "BUCKAROO_GIROPAY";
	readonly BUCKAROO_EPS: "BUCKAROO_EPS";
	readonly BUCKAROO_SOFORT: "BUCKAROO_SOFORT";
	readonly BUCKAROO_BANCONTACT: "BUCKAROO_BANCONTACT";
	readonly BUCKAROO_IDEAL: "BUCKAROO_IDEAL";
	readonly ATOME: "ATOME";
	readonly KLARNA_CUSTOMER_TOKEN: "KLARNA_CUSTOMER_TOKEN";
};
export type PaymentInstrumentType = (typeof PaymentInstrumentType)[keyof typeof PaymentInstrumentType];
declare const PaymentMethodType: {
	readonly WORLDPAY_IDEAL: "WORLDPAY_IDEAL";
	readonly STRIPE_ACH: "STRIPE_ACH";
	readonly STRIPE_IDEAL: "STRIPE_IDEAL";
	readonly ADYEN_KLARNA: "ADYEN_KLARNA";
	readonly ADYEN_BANCONTACT_CARD: "ADYEN_BANCONTACT_CARD";
	readonly PAY_NL_KAARTDIRECT: "PAY_NL_KAARTDIRECT";
	readonly ADYEN_EPS: "ADYEN_EPS";
	readonly ADYEN_BANCONTACT_PAYCONIQ: "ADYEN_BANCONTACT_PAYCONIQ";
	readonly OMISE_PROMPTPAY: "OMISE_PROMPTPAY";
	readonly OMISE_TRUEMONEY: "OMISE_TRUEMONEY";
	readonly ADYEN_MULTIBANCO: "ADYEN_MULTIBANCO";
	readonly PACYPAY_WECHAT: "PACYPAY_WECHAT";
	readonly PACYPAY_ALIPAY: "PACYPAY_ALIPAY";
	readonly ADYEN_MBWAY: "ADYEN_MBWAY";
	readonly XENDIT_DANA: "XENDIT_DANA";
	readonly XENDIT_SHOPEEPAY: "XENDIT_SHOPEEPAY";
	readonly ADYEN_PAYSHOP: "ADYEN_PAYSHOP";
	readonly ADYEN_PAYTRAIL: "ADYEN_PAYTRAIL";
	readonly CLEARPAY: "CLEARPAY";
	readonly RAPYD_FAST: "RAPYD_FAST";
	readonly RAPYD_PROMPTPAY: "RAPYD_PROMPTPAY";
	readonly RAPYD_GCASH: "RAPYD_GCASH";
	readonly RAPYD_POLI: "RAPYD_POLI";
	readonly RAPYD_GRABPAY: "RAPYD_GRABPAY";
	readonly PRIMER_PAYPAL: "PRIMER_PAYPAL";
	readonly TWOC2P: "TWOC2P";
	readonly NETS: "NETS";
	readonly STRIPE_GIROPAY: "STRIPE_GIROPAY";
	readonly MOLLIE_GIROPAY: "MOLLIE_GIROPAY";
	readonly MOLLIE_EPS: "MOLLIE_EPS";
	readonly PAY_NL_EPS: "PAY_NL_EPS";
	readonly PAY_NL_P24: "PAY_NL_P24";
	readonly MOLLIE_P24: "MOLLIE_P24";
	readonly MOLLIE_SOFORT: "MOLLIE_SOFORT";
	readonly COINBASE: "COINBASE";
	readonly OPENNODE: "OPENNODE";
	readonly MOLLIE_GIFT_CARD: "MOLLIE_GIFTCARD";
	readonly XFERS_PAYNOW: "XFERS_PAYNOW";
	readonly PAYMENT_CARD: "PAYMENT_CARD";
	readonly APPLE_PAY: "APPLE_PAY";
	readonly GOOGLE_PAY: "GOOGLE_PAY";
	readonly PAYPAL: "PAYPAL";
	readonly GO_CARDLESS: "GOCARDLESS";
	readonly KLARNA: "KLARNA";
	readonly PAY_NL_IDEAL: "PAY_NL_IDEAL";
	readonly PAY_NL_SOFORT_BANKING: "PAY_NL_SOFORT_BANKING";
	readonly PAY_NL_BANCONTACT: "PAY_NL_BANCONTACT";
	readonly PAY_NL_PAYPAL: "PAY_NL_PAYPAL";
	readonly PAY_NL_CREDIT_TRANSFER: "PAY_NL_CREDIT_TRANSFER";
	readonly PAY_NL_DIRECT_DEBIT: "PAY_NL_DIRECT_DEBIT";
	readonly PAY_NL_GIROPAY: "PAY_NL_GIROPAY";
	readonly PAY_NL_PAYCONIQ: "PAY_NL_PAYCONIQ";
	readonly HOOLAH: "HOOLAH";
	readonly ADYEN_BLIK: "ADYEN_BLIK";
	readonly ADYEN_MOBILEPAY: "ADYEN_MOBILEPAY";
	readonly ADYEN_VIPPS: "ADYEN_VIPPS";
	readonly ADYEN_GIROPAY: "ADYEN_GIROPAY";
	readonly ADYEN_SOFORT: "ADYEN_SOFORT";
	readonly ADYEN_IDEAL: "ADYEN_IDEAL";
	readonly ADYEN_TRUSTLY: "ADYEN_TRUSTLY";
	readonly ADYEN_ALIPAY: "ADYEN_ALIPAY";
	readonly ADYEN_TWINT: "ADYEN_TWINT";
	readonly ADYEN_BANK_TRANSFER: "ADYEN_BANK_TRANSFER";
	readonly MOLLIE_BANCONTACT: "MOLLIE_BANCONTACT";
	readonly MOLLIE_IDEAL: "MOLLIE_IDEAL";
	readonly BUCKAROO_GIROPAY: "BUCKAROO_GIROPAY";
	readonly BUCKAROO_EPS: "BUCKAROO_EPS";
	readonly BUCKAROO_SOFORT: "BUCKAROO_SOFORT";
	readonly BUCKAROO_BANCONTACT: "BUCKAROO_BANCONTACT";
	readonly BUCKAROO_IDEAL: "BUCKAROO_IDEAL";
	readonly ATOME: "ATOME";
};
export type PaymentMethodType = (typeof PaymentMethodType)[keyof typeof PaymentMethodType];
declare const TokenType: {
	readonly SINGLE_USE: "SINGLE_USE";
	readonly MULTI_USE: "MULTI_USE";
};
export type TokenType = (typeof TokenType)[keyof typeof TokenType];
export type MessageSeverity = "ERROR" | "DEBUG" | "WARN" | "INFO";
export interface BorderStyle {
	borderStyle?: string;
	borderColor?: number | string;
	borderWidth?: number | string;
}
export interface TextAlignmentStyle {
	textAlign?: string;
}
export interface TextStyle {
	color?: string;
	fontFamily?: string;
	fontWeight?: string;
	fontSize?: string;
	fontSmoothing?: string;
	lineHeight?: string;
	textTransform?: string;
	letterSpacing?: string;
}
export interface BlockStyle extends BorderStyle {
	background?: string;
	borderRadius?: number | string;
	boxShadow?: string;
}
export type LogoColor = "DARK" | "LIGHT" | "COLORED";
export interface LoadingScreenStyle {
	color?: string;
}
export interface BaseInputStyle extends TextStyle, BlockStyle {
	height?: number | string;
	paddingHorizontal?: number;
}
export interface InputStyle extends BaseInputStyle {
	hover?: BaseInputStyle;
	focus?: BaseInputStyle;
	placeholder?: BaseInputStyle;
	webkitAutofill?: BaseInputStyle;
	selection?: BaseInputStyle;
}
export interface BaseSubmitButtonStyle extends TextStyle, BlockStyle {
}
export interface SubmitButtonStyle extends BaseSubmitButtonStyle {
	hover?: BaseSubmitButtonStyle;
	focus?: BaseSubmitButtonStyle;
}
export interface SubmitButtonStyles {
	base?: SubmitButtonStyle;
	disabled?: SubmitButtonStyle;
	loading?: SubmitButtonStyle;
}
export interface InputStyles {
	base?: InputStyle;
	error?: InputStyle;
}
export interface BaseSavedPaymentMethodButtonStyle extends TextStyle, BlockStyle {
}
export interface SavedPaymentMethodButtonStyle extends BaseSavedPaymentMethodButtonStyle {
	hover?: BaseSavedPaymentMethodButtonStyle;
	focus?: BaseSavedPaymentMethodButtonStyle;
}
export interface SavedPaymentMethodButtonStyles {
	base?: SavedPaymentMethodButtonStyle;
	selected?: SavedPaymentMethodButtonStyle;
}
export interface ShowMorePaymentMethodsButtonStyles {
	base?: TextStyle;
	disabled?: TextStyle;
}
export interface DirectDebitMandateStyle {
	header?: TextStyle;
	label?: TextStyle;
	content?: TextStyle;
	creditorDetails?: TextStyle;
}
export interface DirectDebitSuccessStyle {
	icon?: {
		color?: string;
	};
}
export interface PaymentMethodButtonStyle extends BlockStyle {
	height?: number;
	minHeight?: number;
	maxHeight?: number;
	primaryText?: TextStyle;
	logoColor?: LogoColor;
	marginTop?: string;
}
export interface BackButtonStyle {
	color?: string;
}
export interface EditButtonStyle {
	color?: string;
	background?: string;
}
export interface SeparatorStyle {
	color?: string;
}
export interface ErrorMessageStyle extends BlockStyle, TextStyle {
	color?: string;
}
export interface FormSpacings {
	betweenLabelAndInput?: string;
	betweenInputs?: string;
}
export interface FontFace$1 {
	fontFamily?: string;
	src?: string;
	unicodeRange?: string;
	fontVariant?: string;
	fontFeatureSettings?: string;
	fontVariationSettings?: string;
	fontStretch?: string;
	fontWeight?: string;
	fontStyle?: string;
}
export interface Stylesheet {
	href: string;
}
export interface VaultMenuStyle {
	editButton?: EditButtonStyle & TextStyle;
	item?: {
		label?: TextStyle;
		actionButton?: TextStyle;
		confirmButton?: BlockStyle & TextStyle;
	};
}
export interface NetworkErrorStyles {
	button?: {
		base: BlockStyle & TextStyle;
	};
}
export interface ProcessingIndicatorStyle {
	color?: string;
}
export interface CheckoutStyle {
	fontFaces?: Array<FontFace$1>;
	stylesheets?: Array<Stylesheet>;
	loadingScreen?: LoadingScreenStyle;
	input?: InputStyles;
	inputLabel?: TextStyle;
	inputErrorText?: TextStyle & TextAlignmentStyle;
	formSpacings?: FormSpacings;
	showMorePaymentMethodsButton?: ShowMorePaymentMethodsButtonStyles;
	networkError?: NetworkErrorStyles;
	submitButton?: SubmitButtonStyles;
	vaultTitle?: TextStyle;
	savedPaymentMethodButton?: SavedPaymentMethodButtonStyles;
	paymentMethodButton?: PaymentMethodButtonStyle;
	errorMessage?: ErrorMessageStyle;
	smallPrint?: TextStyle;
	directDebit?: {
		mandate?: DirectDebitMandateStyle;
		success?: DirectDebitSuccessStyle;
	};
	vaultMenu?: VaultMenuStyle;
	backButton?: BackButtonStyle;
	separator?: SeparatorStyle;
	processingIndicator?: ProcessingIndicatorStyle;
	focusCheckoutOnInit?: boolean;
}
declare enum CheckoutUXFlow {
	CHECKOUT = "CHECKOUT",
	HEADLESS_CHECKOUT = "HEADLESS_CHECKOUT",
	MANAGE_PAYMENT_METHODS = "MANAGE_PAYMENT_METHODS"
}
export interface BasePaymentInstrumentData {
	[key: string]: unknown;
}
export interface PaymentCardInstrumentData extends BasePaymentInstrumentData {
	last4Digits: string;
	first6Digits: string;
	expirationMonth: string;
	expirationYear: string;
	cardholderName: string;
	network: string;
	isNetworkTokenized: boolean;
	binData?: {
		network: string;
		issuerCountryCode: string;
		issuerName: string;
		issuerCurrencyCode: string;
		regionalRestriction: string;
		accountNumberType: string;
		accountFundingType: string;
		prepaidReloadableIndicator: string;
		productUsageType: string;
		productCode: string;
		productName: string;
	};
}
export interface PayPalInstrumentData extends BasePaymentInstrumentData {
	externalPayerInfo?: {
		externalPayerId?: string;
		firstName?: string;
		lastName?: string;
		email?: string;
	};
	shippingAddress?: {
		firstName?: string;
		lastName?: string;
		addressLine1?: string;
		addressLine2?: string;
		city?: string;
		state?: string;
		countryCode?: string;
		postalCode?: string;
	};
}
export interface KlarnaInstrumentData extends BasePaymentInstrumentData {
	sessionData?: {
		billingAddress?: {
			firstName?: string;
			lastName?: string;
			email?: string;
			phoneNumber?: string;
			addressLine1?: string;
			addressLine2?: string;
			city?: string;
			state?: string;
			countryCode?: string;
			postalCode?: string;
		};
	};
}
export interface ACHInstrumentData extends BasePaymentInstrumentData {
	accountNumberLastFourDigits: string;
	bankName: string;
	accountType?: string;
	routingNumber?: string;
}
export interface IVaultedPaymentMethod<B extends BasePaymentInstrumentData = BasePaymentInstrumentData, I extends PaymentInstrumentType = PaymentInstrumentType, T extends PaymentMethodType = PaymentMethodType> {
	id: string;
	analyticsId: string;
	paymentInstrumentData: B;
	paymentInstrumentType: I;
	paymentMethodType: T;
	threeDSecureAuthentication?: ThreeDSAuthenticationData | null;
	vaultData?: VaultData | null;
	userDescription?: string;
	isVaulted?: boolean;
}
export type PaymentCardVaultedMethod = IVaultedPaymentMethod<PaymentCardInstrumentData, typeof PaymentInstrumentType.CARD, typeof PaymentMethodType.PAYMENT_CARD>;
export type PayPalVaultedMethod = IVaultedPaymentMethod<PayPalInstrumentData, typeof PaymentInstrumentType.PAYPAL_VAULTED, typeof PaymentMethodType.PAYPAL>;
export type KlarnaVaultedMethod = IVaultedPaymentMethod<KlarnaInstrumentData, typeof PaymentInstrumentType.KLARNA_CUSTOMER_TOKEN, typeof PaymentMethodType.KLARNA>;
export type ACHVaultedMethod = IVaultedPaymentMethod<ACHInstrumentData, typeof PaymentInstrumentType.AUTOMATED_CLEARING_HOUSE, typeof PaymentMethodType.STRIPE_ACH>;
export type VaultedPaymentMethod = PaymentCardVaultedMethod | PayPalVaultedMethod | KlarnaVaultedMethod | ACHVaultedMethod | IVaultedPaymentMethod;
export type SecureInputOptions = {
	ariaLabel?: string;
	container: string | Element | HTMLElement;
	id?: string;
	name: string;
	placeholder?: string;
	placement?: "append" | "prepend";
	properties?: any;
	style?: CheckoutStyle;
	allowedCharactersMap?: Record<string, string>;
};
export type SecureInputListener = (...args: unknown[]) => void;
export type CardSecurityCodeInputOptions = Omit<SecureInputOptions, "allowedCharactersMap" | "name"> & {
	cardNetwork?: string;
	name?: string;
};
export type CvvInput = {
	frame: HTMLIFrameElement | null;
	readonly metadata: {
		readonly errorCode: string | null;
		readonly error: string | null;
		readonly valid: boolean;
		readonly active: boolean;
		readonly dirty: boolean;
		readonly touched: boolean;
		readonly submitted: boolean;
	};
	focus(): void;
	blur(): void;
	addListener(event: "change" | "blur" | "focus", listener: SecureInputListener): (() => void) | undefined;
	addEventListener(event: "change" | "blur" | "focus", listener: SecureInputListener): (() => void) | undefined;
	removeListener(event: "change" | "blur" | "focus", listener: SecureInputListener): void;
	name: string;
	valueToken: string;
	remove: () => void;
};
export type CvvInputOptions = CardSecurityCodeInputOptions;
export interface HeadlessVaultManager {
	fetchVaultedPaymentMethods(): Promise<VaultedPaymentMethod[]>;
	deleteVaultedPaymentMethod(id: string): Promise<void>;
	startPaymentFlow(id: string, data?: {
		cvv?: string;
	}): Promise<void>;
	createCvvInput(options: CvvInputOptions): Promise<CvvInput | null>;
}
declare enum PaymentFlow {
	DEFAULT = "DEFAULT",
	PREFER_VAULT = "PREFER_VAULT"
}
declare enum ThreeDSecureStatus {
	SUCCESS = "AUTH_SUCCESS",
	FAILED = "AUTH_FAILED",
	SKIPPED = "SKIPPED",
	CHALLENGE = "CHALLENGE"
}
declare enum ErrorCode {
	INITIALIZATION_ERROR = "INITIALIZATION_ERROR",
	NO_PAYMENT_METHODS = "NO_PAYMENT_METHODS",
	PRIMER_TEARDOWN = "PRIMER_TEARDOWN",
	PRIMER_SERVER_ERROR = "PRIMER_SERVER_ERROR",
	THREE_DS_AUTH_FAILED = "THREE_DS_AUTH_FAILED",
	TOKENIZATION_ERROR = "TOKENIZATION_ERROR",
	DUPLICATE_PAYMENT_METHOD_ERROR = "DUPLICATE_PAYMENT_METHOD_ERROR",
	CARD_NUMBER_ERROR = "CARD_NUMBER_ERROR",
	PAYMENT_METHOD_NOT_SETUP = "PAYMENT_METHOD_NOT_SETUP",
	PAYMENT_METHOD_NOT_PROVIDED = "PAYMENT_METHOD_NOT_PROVIDED",
	PAYMENT_METHOD_NOT_COMPATIBLE = "PAYMENT_METHOD_NOT_COMPATIBLE",
	RESUME_ERROR = "RESUME_ERROR",
	VALIDATION_ERROR = "VALIDATION_ERROR",
	PAYMENT_FAILED = "PAYMENT_FAILED",
	PAYMENT_CREATION_ABORTED = "PAYMENT_CREATION_ABORTED",
	PAYMENT_CREATION_DISABLED = "PAYMENT_CREATION_DISABLED",
	CLIENT_SESSION_UPDATE_ERROR = "CLIENT_SESSION_UPDATE_ERROR",
	INVALID_ARGUMENT = "INVALID_ARGUMENT",
	VAULT_FETCH = "VAULT_FETCH",
	VAULT_DELETE = "VAULT_DELETE",
	HEADLESS_VAULT_MANAGER_VALIDATION = "HEADLESS_VAULT_MANAGER_VALIDATION",
	CARD_FORM_VALIDATION_UNEXPECTED_FIELD = "CARD_FORM_VALIDATION_UNEXPECTED_FIELD",
	MISSING_FIRST_NAME_OR_LAST_NAME = "MISSING_FIRST_NAME_OR_LAST_NAME",
	MISSING_EMAIL_ADDRESS = "MISSING_EMAIL_ADDRESS",
	INVALID_FLOW = "INVALID_FLOW"
}
declare class SDKError extends Error {
	isReported: boolean;
	constructor(message: string, isReported?: boolean);
	static from(error: unknown, isReported?: boolean): SDKError;
	markAsReported(): void;
}
export interface ErrorOptions$1<T = any> {
	message: string;
	diagnosticsId?: string;
	severity?: MessageSeverity;
	errorId?: string;
	data?: T;
	isFromDeveloper?: boolean;
}
declare class PrimerClientError<T = any> extends SDKError {
	readonly code: ErrorCode;
	readonly diagnosticsId: string | null;
	readonly data?: T;
	readonly isFromDeveloper: boolean;
	static fromErrorCode(code: ErrorCode, options: ErrorOptions$1): PrimerClientError;
	constructor(code: ErrorCode, options: ErrorOptions$1<T>);
}
export interface CardMetadata {
	/** @deprecated Use onCardNetworksChange instead. */
	type: CardNetwork$1 | null;
	/** @deprecated Use onCardNetworksChange instead. */
	possibleTypes: string[];
	cvvLength: number;
	cardNumberLength: number;
}
export interface PositionalConfig {
	container: string | Element;
}
export interface ApplePayOptions extends PositionalConfig {
	buttonType?: "plain" | "buy" | "set-up" | "donate" | "check-out" | "book" | "subscribe";
	buttonStyle?: "white" | "white-outline" | "black";
	/**
	 * @deprecated Add `postalAddress` to `billingOptions.requiredBillingContactFields` instead.
	 */
	captureBillingAddress?: boolean;
	billingOptions?: ApplePayBillingOptions;
	shippingOptions?: ApplePayShippingOptions;
}
export interface ApplePayBillingOptions {
	requiredBillingContactFields?: RequiredContactFields[];
}
export interface ApplePayShippingOptions {
	requiredShippingContactFields?: RequiredContactFields[];
	requireShippingMethod?: boolean;
}
export type RequiredContactFields = "emailAddress" | "name" | "phoneNumber" | "postalAddress" | "phoneticName";
export interface DirectDebitOptions {
	customerCountryCode: Alpha2CountryCode;
	companyName: string;
	companyAddress: string;
	customerName?: string;
	customerEmail?: string;
	customerAddressLine1?: string;
	customerAddressLine2?: string;
	customerCity?: string;
	customerPostalCode?: string;
	iban?: string;
	submitButtonLabels?: {
		form?: Label;
		mandate: Label;
	};
}
export type GooglePayButtonType = 
/** @deprecated Set buttonSizeMode to fill instead  */
"long"
/** @deprecated Set buttonSizeMode to static instead */
 | "short" | "book" | "buy" | "checkout" | "donate" | "order" | "pay" | "plain" | "subscribe";
export type GooglePayButtonColor = "default" | "black" | "white";
export type GooglePayButtonSizeMode = "fill" | "static";
export interface GooglePayShippingAddressParameters {
	phoneNumberRequired?: boolean;
}
export interface GooglePayOptions extends PositionalConfig {
	buttonType?: GooglePayButtonType;
	buttonColor?: GooglePayButtonColor;
	buttonSizeMode?: GooglePayButtonSizeMode;
	onClick?: () => void;
	captureBillingAddress?: boolean;
	shippingAddressParameters?: GooglePayShippingAddressParameters;
	emailRequired?: boolean;
	requireShippingMethod?: boolean;
	shadowRoot?: boolean;
}
export interface PayPalOptions extends PositionalConfig {
	buttonColor?: "gold" | "blue" | "silver" | "white" | "black";
	buttonShape?: "pill" | "rect";
	buttonSize?: "small" | "medium" | "large" | "responsive";
	buttonHeight?: number;
	buttonLabel?: "checkout" | "credit" | "pay" | "buynow" | "paypal" | "installment";
	buttonTagline?: boolean;
	paymentFlow?: PaymentFlow;
	onClick?: () => void;
}
export interface SubmitButtonOptions {
	amountVisible?: boolean;
	useBuiltInButton?: boolean;
	onVisible?: (isVisible: boolean, context: {
		currentSceneId: string;
		previousSceneId?: string;
	}) => void;
	onContentChange?: (content: string, context: {
		currentSceneId: string;
	}) => void;
	onDisable?: (isDisabled: boolean, context: {
		currentSceneId: string;
	}) => void;
	onLoading?: (isLoading: boolean, context: {
		currentSceneId: string;
	}) => void;
}
export interface ProcessingIndicatorOptions {
	visible?: boolean;
}
export interface FormOptions {
	inputLabelsVisible?: boolean;
}
export type CardPreferredFlow = "DEDICATED_SCENE" | "EMBEDDED_IN_HOME";
export interface CheckoutCardOptions {
	cardholderName?: {
		/**
		 * Only works if the cardholder name is visible
		 */
		required?: boolean;
		/**
		 * @deprecated Set it on your Dashboard
		 */
		visible?: boolean;
		placeholder?: Label;
	};
	cardNumber?: {
		placeholder?: Label;
	};
	expiryDate?: {
		placeholder?: Label;
	};
	cvv?: {
		placeholder?: Label;
	};
	preferredFlow?: CardPreferredFlow;
}
export interface ErrorMessageOptions {
	disabled?: boolean;
	onErrorMessageShow?: (message: string) => void;
	onErrorMessageHide?: () => void;
}
declare enum SuccessScreenType {
	PAYMENT_METHOD = "PAYMENT_METHOD",
	CHECK = "CHECK"
}
export interface StripeAchCustomerDetails {
	emailAddress: string;
	firstName: string;
	lastName: string;
}
export interface StripeOptions {
	publishableKey: string;
}
export interface StripeOptionsDropInWithFullMandateText extends StripeOptions {
	mandateData: {
		fullMandateText: string;
		merchantName?: never;
	};
}
export interface StripeOptionsDropInTextProvidedByPrimer extends StripeOptions {
	mandateData: {
		merchantName: string;
		fullMandateText?: never;
	};
}
export type StripeOptionsDropIn = StripeOptionsDropInWithFullMandateText | StripeOptionsDropInTextProvidedByPrimer;
type CardNetwork$1 = "american-express" | "diners-club" | "discover" | "elo" | "hiper" | "hipercard" | "interac" | "jcb" | "maestro" | "mastercard" | "mir" | "unionpay" | "private-label" | "visa";
export interface CustomizablePaymentMethodButton {
	logoSrc: string;
	background: string;
	logoAlt?: string;
	text?: string;
}
export type KlarnaPaymentCategoryType = "pay_now" | "pay_later" | "pay_over_time";
export interface KlarnaButtonOptions {
	text?: string;
}
export interface AdyenKlarnaOptions {
	buttonOptions?: KlarnaButtonOptions;
}
export interface KlarnaOptions {
	paymentFlow?: PaymentFlow;
	recurringPaymentDescription?: string;
	allowedPaymentCategories?: KlarnaPaymentCategoryType[];
	buttonOptions?: KlarnaButtonOptions;
}
export type SupportedLocale = string;
export type Alpha2CountryCode = string;
export type Alpha3CurrencyCode = string;
export type Label<T extends Record<string, unknown> = Record<string, unknown>> = string | ((options: {
	locale: SupportedLocale;
} | T) => string);
export type ResumeToken = {
	resumeToken: string;
	paymentId?: string;
};
export interface InputValidationError {
	field?: string;
	name: string;
	error: string;
	message: string;
}
export interface Validation {
	valid: boolean;
	validationErrors: InputValidationError[];
	error?: string;
}
export interface InputMetadata {
	errorCode: string | null;
	error: string | null;
	valid: boolean;
	active: boolean;
	dirty: boolean;
	touched: boolean;
	submitted: boolean;
}
export interface ExternalPayerInfo {
	externalPayerId: string;
	firstName?: string;
	lastName?: string;
	email?: string;
}
export interface CustomerAddress {
	firstName?: string;
	lastName?: string;
	addressLine1?: string;
	addressLine2?: string;
	addressLine3?: string;
	city?: string;
	state?: string;
	countryCode?: Alpha2CountryCode;
	postalCode?: string;
}
export interface MonetaryAmount {
	value: number | string;
	currency: Alpha3CurrencyCode;
}
export interface ThreeDSecureOrderDetails {
	amount: MonetaryAmount;
	email: string;
	billingAddress: CustomerAddress;
	orderId: string;
}
export interface ThreeDSVerificationOptions {
	token: string;
	container: string;
	order: ThreeDSecureOrderDetails;
	testScenario?: string;
	onChallengeStart?: () => void;
	onChallengeEnd?: () => void;
}
export interface ThreeDSAuthenticationData {
	responseCode: ThreeDSecureStatus;
	reasonCode?: string;
	reasonText?: string;
	protocolVersion: string;
	challengeIssued: boolean;
}
export interface VaultData {
	customerId: string;
}
export type PaymentCardDetails = {
	last4Digits: string;
	cardholderName: string;
	network: string;
};
export type PayPalBillingAgreementDetails = {
	paypalBillingAgreementId: string;
	externalPayerInfo?: ExternalPayerInfo;
	shippingAddress?: CustomerAddress;
};
export type GoCardlessDetails = {
	gocardlessMandateId: string;
};
export type BasePaymentInstrumentData$1 = Record<string, unknown>;
export interface IPaymentMethodToken<T extends BasePaymentInstrumentData$1 = BasePaymentInstrumentData$1, U extends PaymentInstrumentType = PaymentInstrumentType> {
	token: string;
	analyticsId: string;
	tokenType: TokenType;
	paymentInstrumentData: T;
	paymentInstrumentType: U;
	threeDSecureAuthentication: ThreeDSAuthenticationData | null;
	vaultData: VaultData | null;
}
export type UnknownPaymentMethodToken = IPaymentMethodToken<BasePaymentInstrumentData$1, PaymentInstrumentType>;
export type PaymentCardToken = IPaymentMethodToken<PaymentCardDetails, typeof PaymentInstrumentType.CARD>;
export type PayPalBillingAgreementToken = IPaymentMethodToken<PayPalBillingAgreementDetails, typeof PaymentInstrumentType.PAYPAL_VAULTED>;
export type GoCardlessToken = IPaymentMethodToken<GoCardlessDetails, typeof PaymentInstrumentType.GO_CARDLESS>;
export type IdealPayToken = IPaymentMethodToken<Record<string, never>, typeof PaymentInstrumentType.PAY_NL_IDEAL>;
export type PaymentMethodToken = PaymentCardToken | PayPalBillingAgreementToken | GoCardlessToken | IdealPayToken | UnknownPaymentMethodToken;
export type CheckSuccessScreenOptions = {
	type: SuccessScreenType.CHECK;
	title: Label;
};
export type PaymentMethodSuccessScreenOptions = {
	type: SuccessScreenType.PAYMENT_METHOD;
};
export type SuccessScreenOptions = /* No success screen will be displayed */ false | /* Show the default success screen of the payment method*/ undefined | CheckSuccessScreenOptions | PaymentMethodSuccessScreenOptions;
export type VaultOptions = {
	visible?: boolean;
	deletionDisabled?: boolean;
};
export type TransitionType = "SLIDE_UP" | "SLIDE_DOWN" | "SLIDE_HORIZONTAL";
export type SceneTransitionOptions = {
	type: TransitionType;
	duration: number;
	isRtlLocale?: boolean;
};
export type SceneOptions = {
	onEntering?: (sceneId: string) => void;
	transition?: SceneTransitionOptions | false;
};
export type RedirectOptions = {
	returnUrl?: string;
	/**
	 * default: false
	 */
	forceRedirect?: boolean;
};
export type AdvancedOptions = {
	platform?: "STANDALONE" | "MAGENTO";
};
export type PaymentMethodAction = "PAYMENT_METHOD_SELECTED" | "PAYMENT_METHOD_UNSELECTED";
export type PaymentHandling = "AUTO" | "MANUAL";
export type PaymentMethodData$1 = AdyenMultibancoPaymentData;
export type AdyenMultibancoPaymentData = {
	paymentMethodType: typeof PaymentMethodType.ADYEN_MULTIBANCO;
	reference: string;
	expiresAt: string;
	entity: string;
};
export type Payment = {
	id: string;
	orderId: string;
	paymentMethodData?: PaymentMethodData$1;
};
export interface onBeforePaymentCreateHandler {
	continuePaymentCreation: () => void;
	abortPaymentCreation: () => void;
}
export interface OnCheckoutFailHandler {
	showErrorMessage: (errorMessage?: string) => void;
}
export interface PaymentHandlers {
	onBeforePaymentCreate?: (data: {
		paymentMethodType?: PaymentMethodType;
	}, handler: onBeforePaymentCreateHandler) => void;
	onPaymentCreationStart?: () => void;
	onCheckoutComplete?: (data: {
		payment: Payment | null;
	}) => void;
	onCheckoutFail?: (error: PrimerClientError, data: {
		payment?: Payment;
	}, handler: OnCheckoutFailHandler | undefined) => void;
}
export type OnTokenizeShouldStart = (data: {
	paymentMethodType?: PaymentMethodType;
}) => boolean | Promise<boolean>;
export type OnTokenizeDidNotStart = (reason: string) => void;
export type OnTokenizeStart = () => void;
export type OnTokenizeError = (error: PrimerClientError) => void;
export interface OnTokenizeSuccessHandler {
	handleSuccess(): any;
	handleFailure(errorMessage?: string): any;
	continueWithNewClientToken(clientToken: string): any;
}
export type OnTokenizeSuccess = (data: PaymentMethodToken, handler: OnTokenizeSuccessHandler) => void | Promise<void>;
export interface OnResumeSuccessHandler {
	handleSuccess(): any;
	handleFailure(errorMessage?: string): any;
	continueWithNewClientToken(clientToken: string): any;
}
export type OnResumeSuccess = (data: ResumeToken, handler: OnResumeSuccessHandler) => void;
export type onResumeError = (error: PrimerClientError) => void;
export type OnResumePending = (paymentMethodData: PaymentMethodData$1) => void;
export interface TokenizationHandlers {
	onTokenizeShouldStart?: OnTokenizeShouldStart;
	onTokenizeDidNotStart?: OnTokenizeDidNotStart;
	onTokenizeStart?: OnTokenizeStart;
	onTokenizeSuccess?: OnTokenizeSuccess;
	onTokenizeError?: OnTokenizeError;
	onResumeSuccess?: OnResumeSuccess;
	onResumePending?: OnResumePending;
	onResumeError?: onResumeError;
}
export interface PaymentMethodHandlers {
	onPaymentMethodAction?: (paymentMethodAction: PaymentMethodAction, { paymentMethodType, }: {
		paymentMethodType: PaymentMethodType | string | null;
	}) => void;
}
export interface ClientSessionHandlers {
	onClientSessionUpdate?: (clientSession: ClientSession) => void;
	onBeforeClientSessionUpdate?: () => void;
}
export interface VaultManagerOptions extends WithAllowedCardNetworks {
	uxFlow?: CheckoutUXFlow.MANAGE_PAYMENT_METHODS;
	container: string | Element;
	locale?: SupportedLocale;
	vaultOnly?: boolean;
	deletionDisabled?: boolean;
	style?: CheckoutStyle;
	scene?: SceneOptions;
	errorMessage?: ErrorMessageOptions;
	form?: FormOptions;
	submitButton?: SubmitButtonOptions;
	processingIndicator?: ProcessingIndicatorOptions;
	card?: CheckoutCardOptions;
	threeDSecure?: ThreeDSVerificationOptions;
	giftCard?: CustomizablePaymentMethodButton;
	googlePay?: Omit<GooglePayOptions, "container">;
	directDebit?: DirectDebitOptions;
	stripe?: StripeOptionsDropIn;
	paypal?: Omit<PayPalOptions, "container">;
	onTokenizeShouldStart?: OnTokenizeShouldStart;
	onTokenizeDidNotStart?: OnTokenizeDidNotStart;
	onTokenizeStart?: () => void;
	onTokenizeSuccess?: (data: PaymentMethodToken) => void;
	onTokenizeError?: (message: PrimerClientError) => void;
	apiVersion?: APIVersionOption;
}
export interface UniversalCheckoutOptions extends TokenizationHandlers, PaymentHandlers, PaymentMethodHandlers, ClientSessionHandlers, WithAllowedCardNetworks {
	uxFlow?: CheckoutUXFlow.CHECKOUT;
	container: string | Element;
	locale?: SupportedLocale;
	style?: CheckoutStyle;
	scene?: SceneOptions;
	vault?: VaultOptions;
	submitButton?: SubmitButtonOptions;
	processingIndicator?: ProcessingIndicatorOptions;
	errorMessage?: ErrorMessageOptions;
	successScreen?: SuccessScreenOptions;
	form?: FormOptions;
	allowedPaymentMethods?: PaymentMethodType[];
	card?: CheckoutCardOptions;
	redirect?: RedirectOptions;
	paypal?: Omit<PayPalOptions, "container">;
	googlePay?: Omit<GooglePayOptions, "container">;
	applePay?: Omit<ApplePayOptions, "container">;
	adyenKlarna?: AdyenKlarnaOptions;
	klarna?: KlarnaOptions;
	directDebit?: DirectDebitOptions;
	giftCard?: CustomizablePaymentMethodButton;
	stripe?: StripeOptionsDropIn;
	paymentHandling?: PaymentHandling;
	advanced?: AdvancedOptions;
	clientSessionCachingEnabled?: boolean;
	apiVersion?: APIVersionOption;
}
export interface HeadlessUniversalCheckoutOptions extends TokenizationHandlers, PaymentHandlers, PaymentMethodHandlers, ClientSessionHandlers, WithAllowedCardNetworks {
	style?: CheckoutStyle;
	paymentHandling?: PaymentHandling;
	locale?: SupportedLocale;
	card?: CheckoutCardOptions;
	redirect?: RedirectOptions;
	paypal?: Omit<PayPalOptions, "container">;
	googlePay?: Omit<GooglePayOptions, "container">;
	applePay?: Omit<ApplePayOptions, "container">;
	adyenKlarna?: AdyenKlarnaOptions;
	klarna?: KlarnaOptions;
	directDebit?: DirectDebitOptions;
	giftCard?: CustomizablePaymentMethodButton;
	stripe?: StripeOptions;
	onAvailablePaymentMethodsLoad: (paymentMethods: PaymentMethodInfo[]) => void;
	clientSessionCachingEnabled?: boolean;
	apiVersion?: APIVersionOption;
}
export type WithAllowedCardNetworks = {
	/** @deprecated Use `orderedAllowedCardNetworks` on your Primer Dashboard instead. */
	allowedCardNetworks?: CardNetwork$1[];
};
export interface PrimerCheckout {
	teardown(): void;
	submit(): void;
	setPaymentCreationEnabled(isEnabled: boolean): void;
	setTokenizationEnabled(isEnabled: boolean): void;
	refreshClientSession(): Promise<boolean>;
	/**
	 * @deprecated The method should not be used
	 */
	setClientToken(): Promise<boolean>;
}
export type EventListener$1 = (event?: Event) => void;
declare enum EventTypes {
	CHANGE = "change",
	ERROR = "error",
	FOCUS = "focus",
	BLUR = "blur",
	CLICK = "click",
	CLOSE = "close",
	CONFIRMED_KLARNA_CATEGORY = "CONFIRMED_KLARNA_CATEGORY",
	CONFIRMED_KLARNA_CATEGORY_ERROR = "CONFIRMED_KLARNA_CATEGORY_ERROR",
	KLARNA_SESSION_UPDATE = "KLARNA_SESSION_UPDATE",
	KLARNA_SESSION_REFRESH_ERROR = "KLARNA_SESSION_REFRESH_ERROR"
}
export interface HeadlessHostedInputOptions {
	placeholder?: string;
	ariaLabel?: string;
	style?: CheckoutStyle;
}
export interface IHeadlessHostedInput {
	getOptions(): HeadlessHostedInputOptions;
	setOptions(options: HeadlessHostedInputOptions): void;
	render(container: string | Element | null, options: HeadlessHostedInputOptions): Promise<void>;
	addEventListener(event: EventTypes, callback: EventListener$1): void;
	focus(): void;
	blur(): void;
	setDisabled(status: boolean): void;
}
export interface ICardPaymentMethodManager {
	createHostedInputs(): {
		cardNumberInput: IHeadlessHostedInput;
		expiryInput: IHeadlessHostedInput;
		cvvInput: IHeadlessHostedInput;
	};
	setCardholderName(cardholderName: string): void;
	removeHostedInputs(): void;
	submit(values?: CardPaymentMethodSubmitValues): Promise<void>;
	validate(): Promise<Validation>;
	reset(): void;
}
export type CardPaymentMethodSubmitValues = {
	cardNetwork?: string;
};
export interface PayPalStyles {
	buttonColor?: "gold" | "blue" | "silver" | "white" | "black";
	buttonShape?: "pill" | "rect";
	buttonSize?: "small" | "medium" | "large" | "responsive";
	buttonHeight?: number;
	buttonLabel?: "checkout" | "credit" | "pay" | "buynow" | "paypal" | "installment";
	buttonTagline?: boolean;
}
export interface GooglePayStyles {
	buttonType?: "long" | "short";
	buttonColor?: "default" | "black" | "white";
	shadowRoot?: boolean;
}
export interface ApplePayStyles {
	buttonType?: "plain" | "buy" | "set-up" | "donate" | "check-out" | "book" | "subscribe";
	buttonHeight?: number;
	buttonStyle?: "white" | "white-outline" | "black";
}
export interface HeadlessButtonRenderOptions {
	style?: GooglePayStyles | PayPalStyles | ApplePayStyles | Record<string, unknown>;
}
export interface IHeadlessPaymentMethodButton {
	render(containerId: string | Element, options: HeadlessButtonRenderOptions): Promise<void>;
	setDisabled(disabled: boolean): Promise<void>;
	clean(): void;
	focus(): void;
	blur(): void;
	addEventListener(event: EventTypes, callback: EventListener$1): void;
}
export interface INativePaymentMethodManager {
	createButton(): IHeadlessPaymentMethodButton;
}
export interface IRedirectPaymentMethodManager {
	start(): Promise<void>;
	addEventListener(event: EventTypes, callback: EventListener$1): void;
}
export interface IKlarnaPaymentMethodManager {
	start(paymentPayload: KlarnaPaymentPayload): Promise<KlarnaPaymentResponse>;
	renderCategory(renderCategoryDetails: RenderCategoryDetails): Promise<void>;
	addEventListener(event: EventTypes, callback: EventListener$1): void;
	getPaymentMethod(): void;
}
export interface IAchPaymentMethodManager {
	start(paymentDetails: StripeAchCustomerDetails): Promise<Validation | void>;
	setAndValidate(paymentDetails: StripeAchCustomerDetails): Promise<Validation>;
	collectBankAccountDetails(): Promise<void>;
	confirmMandate(): Promise<void>;
	declineMandate(): Promise<void>;
	getPaymentMethod(): void;
}
declare enum HeadlessManagerType {
	CARD = "CARD",
	NATIVE = "NATIVE",
	REDIRECT = "REDIRECT",
	KLARNA = "KLARNA",
	ACH = "ACH"
}
export type PaymentMethodInfo = {
	type: PaymentMethodType;
	managerType: HeadlessManagerType;
};
export type ButtonPaymentMethodAsset = {
	backgroundColor: BackgroundColor;
	iconUrl: IconUrl;
	/**
	 * @deprecated The property should not be used. Please use displayName or buttonText instead
	 */
	paymentMethodName?: string;
	buttonText?: string;
	displayName?: string;
};
export interface IAssetsManager {
	getCardNetworkAsset(cardNetwork: string): Promise<CardNetworkAsset>;
	getPaymentMethodAsset(type: PaymentMethodType): Promise<ButtonPaymentMethodAsset | null>;
}
export type CardNetworkAsset = {
	cardUrl: string;
	displayName: string;
};
export interface CardPaymentMethodManagerOptions {
	/** @deprecated Use onCardNetworksChange instead. */
	onCardMetadataChange?: (metadata: CardMetadata) => void;
	onCardNetworksChange?: (event: CardNetworkChangeEvent) => void;
	onCardNetworksLoading?: () => void;
}
export type CardNetworkChangeEvent = {
	detectedCardNetworks: CardNetworks;
	selectableCardNetworks?: CardNetworks;
	source: "REMOTE" | "LOCAL" | "LOCAL_FALLBACK";
};
export type CardNetworks = {
	items: CardNetworkDetails[];
	preferred?: CardNetworkDetails;
};
export type CardNetworkDetails = CardNetworkInfo & {
	allowed: boolean;
};
export type CardNetworkInfo = {
	displayName: string;
	network: string;
};
export type BankIssuer = {
	id: string;
	name: string;
	iconUrl: string;
	disabled: boolean;
};
export interface FormWithRedirectConfiguration {
	bankIssuers?: BankIssuer[];
	error?: PrimerClientError | Error;
}
export interface FormWithRedirectPaymentMethodManagerOptions {
	onConfigurationLoad?: (payload: FormWithRedirectConfiguration) => void;
}
export interface KlarnaPaymentMethodManagerOptions {
	onPaymentMethodCategoriesChange?: (paymentMethodCategories: KlarnaPaymentMethodCategory[]) => void;
	onPaymentMethodAction?: (action: string, data: {
		paymentMethodType: string;
		category: string;
	}) => void;
}
export interface AchPaymentMethodManagerOptions {
	onCollectBankAccountDetailsComplete?: () => void;
}
export type KlarnaPaymentMethodCategory = {
	id: string;
	name: string;
	descriptiveAssetUrl: string;
	standardAssetUrl: string;
};
export type KlarnaPaymentPayload = {
	paymentMethodCategoryId: string;
};
export type KlarnaPaymentResponse = {
	outcome: "APPROVED" | "DENIED";
};
export type RenderCategoryDetails = {
	containerId: string | Element;
	paymentMethodCategoryId: string;
	onHeightChange: (height: number) => void;
};
export interface HeadlessSDKUtilities {
	getCardNetworkAsset(network: string): {
		cardUrl: string;
		displayName: string;
	};
	getUIOrderAmount(): string | null;
	getCDNAssets(paymentMethodType: PaymentMethodType): Promise<GoatBrandWithCdn | undefined>;
	getPaymentMethodConfiguration(paymentMethodType: PaymentMethodType): PaymentMethodConfig | undefined;
}
export type PaymentMethodManagerOptions = CardPaymentMethodManagerOptions | FormWithRedirectPaymentMethodManagerOptions | KlarnaPaymentMethodManagerOptions;
export interface PrimerHeadlessCheckout {
	createPaymentMethodManager(type: "PAYMENT_CARD", options?: PaymentMethodManagerOptions): Promise<ICardPaymentMethodManager | null>;
	createPaymentMethodManager(type: "PAYPAL" | "GOOGLE_PAY" | "APPLE_PAY", options?: PaymentMethodManagerOptions): Promise<INativePaymentMethodManager | null>;
	createPaymentMethodManager(type: "STRIPE_ACH", options?: AchPaymentMethodManagerOptions): Promise<IAchPaymentMethodManager | null>;
	createPaymentMethodManager(type: "KLARNA", options?: PaymentMethodManagerOptions): Promise<IKlarnaPaymentMethodManager | null>;
	createPaymentMethodManager(type: PaymentMethodType, options?: PaymentMethodManagerOptions): Promise<IRedirectPaymentMethodManager | null>;
	createVaultManager(): HeadlessVaultManager;
	getSDKUtilities(): HeadlessSDKUtilities;
	/**
	 * @deprecated
	 * The options should be set on the `createHeadless` second parameter instead:
	 * ```
	 * Primer.createHeadless('clientToken', options);
	 * ```
	 */
	configure: (options: Omit<HeadlessUniversalCheckoutOptions, "clientSessionCachingEnabled">) => void;
	getAssetsManager(): IAssetsManager;
	start: () => Promise<void>;
	refreshClientSession(): Promise<boolean>;
}
export interface PrimerVaultManager {
	teardown(): void;
	submit(): void;
}
declare const Primer: {
	SDK_VERSION: string;
	createHeadless: (clientToken: string, options?: HeadlessUniversalCheckoutOptions | undefined) => Promise<Promise<PrimerHeadlessCheckout>>;
	showUniversalCheckout: (clientToken: string, options?: UniversalCheckoutOptions | undefined) => Promise<Promise<PrimerCheckout>>;
	showVaultManager: (clientToken: string, options?: VaultManagerOptions | undefined) => Promise<Promise<PrimerVaultManager>>;
	preloadPrimer: () => Promise<void>;
};
export type JSONSafe<T> = T extends (...args: any[]) => any ? never : T extends symbol ? never : T extends bigint ? never : T extends Array<infer U> ? JSONSafe<U>[] : T extends object ? {
	[K in keyof T as JSONSafe<T[K]> extends never ? never : K]: JSONSafe<T[K]>;
} : T;
export type PrimerCheckoutOptions = JSONSafe<HeadlessUniversalCheckoutOptions> & {
	vault?: {
		enabled: boolean;
	};
	submitButton?: {
		amountVisible?: boolean;
	};
	stripe?: UniversalCheckoutOptions["stripe"];
};
declare global {
	interface Window {
		Primer: typeof Primer;
	}
}
declare const PaymentMethodType$1: {
	readonly WORLDPAY_IDEAL: "WORLDPAY_IDEAL";
	readonly STRIPE_ACH: "STRIPE_ACH";
	readonly STRIPE_IDEAL: "STRIPE_IDEAL";
	readonly ADYEN_KLARNA: "ADYEN_KLARNA";
	readonly ADYEN_BANCONTACT_CARD: "ADYEN_BANCONTACT_CARD";
	readonly PAY_NL_KAARTDIRECT: "PAY_NL_KAARTDIRECT";
	readonly ADYEN_EPS: "ADYEN_EPS";
	readonly ADYEN_BANCONTACT_PAYCONIQ: "ADYEN_BANCONTACT_PAYCONIQ";
	readonly OMISE_PROMPTPAY: "OMISE_PROMPTPAY";
	readonly OMISE_TRUEMONEY: "OMISE_TRUEMONEY";
	readonly ADYEN_MULTIBANCO: "ADYEN_MULTIBANCO";
	readonly PACYPAY_WECHAT: "PACYPAY_WECHAT";
	readonly PACYPAY_ALIPAY: "PACYPAY_ALIPAY";
	readonly ADYEN_MBWAY: "ADYEN_MBWAY";
	readonly XENDIT_DANA: "XENDIT_DANA";
	readonly XENDIT_SHOPEEPAY: "XENDIT_SHOPEEPAY";
	readonly ADYEN_PAYSHOP: "ADYEN_PAYSHOP";
	readonly ADYEN_PAYTRAIL: "ADYEN_PAYTRAIL";
	readonly CLEARPAY: "CLEARPAY";
	readonly RAPYD_FAST: "RAPYD_FAST";
	readonly RAPYD_PROMPTPAY: "RAPYD_PROMPTPAY";
	readonly RAPYD_GCASH: "RAPYD_GCASH";
	readonly RAPYD_POLI: "RAPYD_POLI";
	readonly RAPYD_GRABPAY: "RAPYD_GRABPAY";
	readonly PRIMER_PAYPAL: "PRIMER_PAYPAL";
	readonly TWOC2P: "TWOC2P";
	readonly NETS: "NETS";
	readonly STRIPE_GIROPAY: "STRIPE_GIROPAY";
	readonly MOLLIE_GIROPAY: "MOLLIE_GIROPAY";
	readonly MOLLIE_EPS: "MOLLIE_EPS";
	readonly PAY_NL_EPS: "PAY_NL_EPS";
	readonly PAY_NL_P24: "PAY_NL_P24";
	readonly MOLLIE_P24: "MOLLIE_P24";
	readonly MOLLIE_SOFORT: "MOLLIE_SOFORT";
	readonly COINBASE: "COINBASE";
	readonly OPENNODE: "OPENNODE";
	readonly MOLLIE_GIFT_CARD: "MOLLIE_GIFTCARD";
	readonly XFERS_PAYNOW: "XFERS_PAYNOW";
	readonly PAYMENT_CARD: "PAYMENT_CARD";
	readonly APPLE_PAY: "APPLE_PAY";
	readonly GOOGLE_PAY: "GOOGLE_PAY";
	readonly PAYPAL: "PAYPAL";
	readonly GO_CARDLESS: "GOCARDLESS";
	readonly KLARNA: "KLARNA";
	readonly PAY_NL_IDEAL: "PAY_NL_IDEAL";
	readonly PAY_NL_SOFORT_BANKING: "PAY_NL_SOFORT_BANKING";
	readonly PAY_NL_BANCONTACT: "PAY_NL_BANCONTACT";
	readonly PAY_NL_PAYPAL: "PAY_NL_PAYPAL";
	readonly PAY_NL_CREDIT_TRANSFER: "PAY_NL_CREDIT_TRANSFER";
	readonly PAY_NL_DIRECT_DEBIT: "PAY_NL_DIRECT_DEBIT";
	readonly PAY_NL_GIROPAY: "PAY_NL_GIROPAY";
	readonly PAY_NL_PAYCONIQ: "PAY_NL_PAYCONIQ";
	readonly HOOLAH: "HOOLAH";
	readonly ADYEN_BLIK: "ADYEN_BLIK";
	readonly ADYEN_MOBILEPAY: "ADYEN_MOBILEPAY";
	readonly ADYEN_VIPPS: "ADYEN_VIPPS";
	readonly ADYEN_GIROPAY: "ADYEN_GIROPAY";
	readonly ADYEN_SOFORT: "ADYEN_SOFORT";
	readonly ADYEN_IDEAL: "ADYEN_IDEAL";
	readonly ADYEN_TRUSTLY: "ADYEN_TRUSTLY";
	readonly ADYEN_ALIPAY: "ADYEN_ALIPAY";
	readonly ADYEN_TWINT: "ADYEN_TWINT";
	readonly ADYEN_BANK_TRANSFER: "ADYEN_BANK_TRANSFER";
	readonly MOLLIE_BANCONTACT: "MOLLIE_BANCONTACT";
	readonly MOLLIE_IDEAL: "MOLLIE_IDEAL";
	readonly BUCKAROO_GIROPAY: "BUCKAROO_GIROPAY";
	readonly BUCKAROO_EPS: "BUCKAROO_EPS";
	readonly BUCKAROO_SOFORT: "BUCKAROO_SOFORT";
	readonly BUCKAROO_BANCONTACT: "BUCKAROO_BANCONTACT";
	readonly BUCKAROO_IDEAL: "BUCKAROO_IDEAL";
	readonly ATOME: "ATOME";
};
type PaymentMethodType$1 = (typeof PaymentMethodType$1)[keyof typeof PaymentMethodType$1];
export type InitializedManager = {
	type: typeof PaymentMethodType$1.STRIPE_ACH;
	manager: IAchPaymentMethodManager;
} | {
	type: typeof PaymentMethodType$1.PAYMENT_CARD;
	manager: ICardPaymentMethodManager;
} | {
	type: typeof PaymentMethodType$1.KLARNA;
	manager: IKlarnaPaymentMethodManager;
} | {
	type: RedirectPaymentMethodTypes;
	manager: IRedirectPaymentMethodManager;
} | {
	type: typeof PaymentMethodType$1.PAYPAL | typeof PaymentMethodType$1.GOOGLE_PAY | typeof PaymentMethodType$1.APPLE_PAY;
	manager: INativePaymentMethodManager;
};
export type ManagerByType<T extends PaymentMethodType$1> = Extract<InitializedManager, {
	type: T;
}>;
export interface InitializedManagersMap extends Map<PaymentMethodType$1, InitializedManager> {
	get<T extends PaymentMethodType$1>(key: T): ManagerByType<T> | undefined;
}
export type RedirectPaymentMethodTypes = Exclude<PaymentMethodType$1, typeof PaymentMethodType$1.STRIPE_ACH | typeof PaymentMethodType$1.PAYMENT_CARD | typeof PaymentMethodType$1.KLARNA | typeof PaymentMethodType$1.PAYPAL | typeof PaymentMethodType$1.GOOGLE_PAY | typeof PaymentMethodType$1.APPLE_PAY>;
export type DynamicPaymentMethodTypes = typeof PaymentMethodType$1.STRIPE_ACH;
export type NativePaymentMethodTypes = typeof PaymentMethodType$1.PAYPAL | typeof PaymentMethodType$1.GOOGLE_PAY | typeof PaymentMethodType$1.APPLE_PAY;
export type RedirectPaymentMethod = {
	type: RedirectPaymentMethodTypes;
	managerType: HeadlessManagerType.REDIRECT;
};
export type InitializedPaymentMethod = {
	type: typeof PaymentMethodType$1.STRIPE_ACH;
	managerType: HeadlessManagerType.ACH;
} | {
	type: typeof PaymentMethodType$1.PAYMENT_CARD;
	managerType: HeadlessManagerType.CARD;
} | {
	type: typeof PaymentMethodType$1.KLARNA;
	managerType: HeadlessManagerType.KLARNA;
} | {
	type: typeof PaymentMethodType$1.PAYPAL;
	managerType: HeadlessManagerType.NATIVE;
} | {
	type: typeof PaymentMethodType$1.GOOGLE_PAY;
	managerType: HeadlessManagerType.NATIVE;
} | {
	type: typeof PaymentMethodType$1.APPLE_PAY;
	managerType: HeadlessManagerType.NATIVE;
} | RedirectPaymentMethod;
export type PaymentMethodByType<T extends PaymentMethodType$1> = Extract<InitializedPaymentMethod, {
	type: T;
}>;
export interface InitializedPaymentMethodMap extends Map<PaymentMethodType$1, InitializedPaymentMethod> {
	get<T extends PaymentMethodType$1>(key: T): PaymentMethodByType<T> | undefined;
}
export interface AssetsConfig {
	backgroundColor: string;
	name: string;
	iconUrl: string;
}
export declare class InitializedPayments {
	private readonly _methods;
	constructor(map: InitializedPaymentMethodMap);
	get<T extends RedirectPaymentMethodTypes>(type: T): RedirectPaymentMethod | undefined;
	get<T extends (typeof PaymentMethodType$1)[keyof typeof PaymentMethodType$1]>(type: T): PaymentMethodByType<T> | undefined;
	toArray(): InitializedPaymentMethod[];
	size(): number;
}
export interface OnCheckoutCompletePayload {
	payment: Payment | null;
}
export interface OnCheckoutFailurePayload {
	error: PrimerClientError;
	payment?: Payment;
}
export interface CardSubmitSuccessPayload {
	result: unknown;
}
export interface CardSubmitErrorsPayload {
	errors: unknown | InputValidationError[];
}
export interface PrimeAchErrorPayload {
	error: Error;
}
export interface PrimerEvents {
	"primer-state-changed": CustomEvent<SdkStateContext>;
	"primer-oncheckout-complete": CustomEvent<OnCheckoutCompletePayload>;
	"primer-oncheckout-failure": CustomEvent<OnCheckoutFailurePayload>;
	"primer-payment-methods-updated": CustomEvent<InitializedPayments>;
	"primer-checkout-initialized": CustomEvent<PrimerHeadlessCheckout>;
	"primer-card-network-change": CustomEvent<CardNetworksContext>;
	"primer-card-submit-success": CustomEvent<CardSubmitSuccessPayload>;
	"primer-card-submit-errors": CustomEvent<CardSubmitErrorsPayload>;
	"primer-ach-error": CustomEvent<PrimeAchErrorPayload>;
	"primer-ach-bank-details-collected": CustomEvent;
	"primer-ach-mandate-confirmed": CustomEvent;
	"primer-ach-mandate-declined": CustomEvent;
}
declare class PrimerEventsController implements ReactiveController {
	host: ReactiveControllerHost & LitElement;
	constructor(host: ReactiveControllerHost & LitElement);
	hostConnected(): void;
	/**
	 * Dispatch a custom event using the unified naming pattern.
	 * Ensures that every event bubbles and crosses shadow DOM boundaries.
	 *
	 * @param type - The event name as defined in PrimerEvents.
	 * @param detail - The payload for the event.
	 */
	dispatchEvent<K extends keyof PrimerEvents>(type: K, detail: PrimerEvents[K]["detail"]): void;
	dispatchSdkState(sdkState: SdkStateContext): void;
	dispatchPaymentMethods(paymentMethods: InitializedPayments): void;
	dispatchCheckoutInitialized(checkoutInstance: PrimerHeadlessCheckout): void;
	dispatchCardNetworkChange(network: CardNetworksContext): void;
	dispatchOnCheckoutComplete(payment: Payment | null): void;
	dispatchOnCheckoutFailure(error: PrimerClientError, payment?: Payment): void;
	dispatchFormSubmitSuccess(result: unknown): void;
	dispatchFormSubmitErrors(errors: unknown): void;
}
export type HeadlessUnitilsContext = HeadlessSDKUtilities | null;
export type KlarnaCategoriesContext = {
	categories: KlarnaPaymentMethodCategory[];
	isLoading: boolean;
};
export type ReducerCallbacks<State, _Action extends {
	type: string;
}> = {
	[K in keyof State]?: State[K] extends (...args: unknown[]) => unknown ? State[K] : never;
};
export type TypedReducer<State, Action extends {
	type: string;
}, Callbacks> = (state: State, action: Action, callbacks: Callbacks) => State;
declare abstract class ReactiveStateController<Host extends ReactiveControllerHost, State, Action extends {
	type: string;
}, Callbacks = ReducerCallbacks<State, Action> | null> implements ReactiveController {
	protected host: Host;
	protected stateHandler: (state: State) => void;
	private _dispatcher;
	constructor(host: Host, initialState: State, reducer: TypedReducer<State, Action, Callbacks>, initialCallbacks: Callbacks, stateHandler?: (state: State) => void);
	get currentState(): Readonly<State>;
	protected dispatch(action: Action): void;
	protected setCallbacks(callbacks: Partial<Callbacks>): void;
	hostConnected(): void;
	hostDisconnected(): void;
}
declare class CompositeStateController<Host extends ReactiveControllerHost> implements ReactiveController {
	protected host: Host;
	private _controllers;
	constructor(host: Host);
	addController<State, Action extends {
		type: string;
	}, Callbacks = ReducerCallbacks<State, Action> | null>(controller: ReactiveStateController<Host, State, Action, Callbacks>): void;
	hostConnected(): void;
	hostDisconnected(): void;
}
/**
 * Options for initializing the Vault Manager
 */
export interface VaultManagerInitOptions {
	vaultEnabled?: boolean;
	captureVaultedCardCvv?: boolean;
}
/**
 * Core state interface for vault manager
 * Contains properties related to vault functionality that don't change frequently
 */
export interface VaultManagerState {
	enabled: boolean;
	isLoading: boolean;
	isUpdating: boolean;
	vaultedPaymentMethods: VaultedPaymentMethod[];
	cvvRecapture: boolean;
	createCvvInput: ((options: CardSecurityCodeInputOptions) => Promise<CvvInput | null>) | null;
	deleteVaultedPaymentMethod: (paymentMethodId: string) => Promise<void>;
	startVaultedPaymentFlow: (options?: {
		cvv?: string;
	}) => Promise<void>;
}
/**
 * CVV-specific state interface
 * Contains properties specifically related to CVV input functionality
 */
export interface VaultManagerItemState {
	formIsDirty: boolean;
	cvvInput: CvvInput | null;
	setCvvInput: (metadata: CvvInput | null) => void;
	selectedVaultedPaymentMethod: VaultedPaymentMethod | null;
	setSelectedVaultedPaymentMethod: (paymentMethod: VaultedPaymentMethod | null) => void;
}
declare class VaultManagerController extends CompositeStateController<PrimerCheckoutType> {
	private coreController;
	private itemController;
	private _vaultManager;
	private _options;
	constructor(host: PrimerCheckoutType);
	/**
	 * Initialize the vault manager with additional options
	 * @param vaultManager - The HeadlessVaultManager instance
	 * @param options - Additional initialization options
	 */
	initializeVaultManager(vaultManager: HeadlessVaultManager, options?: VaultManagerInitOptions): void;
	get vaultManager(): HeadlessVaultManager | null;
	set vaultManager(vaultManager: HeadlessVaultManager | null);
	get options(): VaultManagerInitOptions | null;
	set options(options: VaultManagerInitOptions | null);
	get vaultManagerState(): Readonly<VaultManagerState>;
	get vaultItemState(): Readonly<VaultManagerItemState>;
	/**
	 * Lifecycle method called when the host disconnects
	 */
	hostDisconnected(): void;
	/**
	 * Fetch vaulted payment methods from the server
	 */
	fetchVaultedPaymentMethods(initialLoad?: boolean): Promise<VaultedPaymentMethod[]>;
	createCvvInput(options: CardSecurityCodeInputOptions): Promise<CvvInput | null>;
	/**
	 * Delete a vaulted payment method by ID
	 */
	deleteVaultedPaymentMethod: (paymentMethodId: string) => Promise<void>;
	/**
	 * Set the CVV metadata - updates CVV state only
	 * Moved to the separate CVV context
	 */
	setCvvInput: (metadata: CvvInput | null) => void;
	/**
	 * Start the vaulted payment flow
	 * Verifies form state validity before processing
	 */
	startVaultedPaymentFlow: () => Promise<void>;
	/**
	 * Set the selected vaulted payment method - updates form state only
	 */
	setSelectedVaultedPaymentMethod: (paymentMethod: VaultedPaymentMethod | null) => void;
}
/**
 * Context for core vault manager functionality
 * Contains properties that don't change frequently and relate to vault functionality
 */
export type VaultManagerContext = VaultManagerState | null;
/**
 * Context for vault manager CVV-specific state
 * Contains properties specifically related to CVV input functionality
 * Further separated to minimize re-renders related to frequently changing CVV input state
 */
export type VaultItemContext = VaultManagerItemState | null;
declare class SDKContextController implements ReactiveController {
	host: PrimerCheckoutType;
	private sdkStateProvider;
	private paymentMethodsProvider;
	private paymentManagerProvider;
	private cardNetworksContext;
	private vaultManagerProvider;
	private vaultManagerCvvProvider;
	private clientOptionsContext;
	private headlessUtilsProvider;
	private klarnaCategoriesProvider;
	private computedStylesProvider;
	constructor(host: PrimerCheckoutType);
	hostConnected(): void;
	/**
	 * Updates the SDK state context.
	 * @param value The new SDK state.
	 */
	setSdkState(value: SdkStateContext): void;
	/**
	 * Updates the payment methods context.
	 * @param value The new payment methods data.
	 */
	setPaymentMethods(value: InitializedPayments): void;
	/**
	 * Updates the payment manager context.
	 * @param value The new payment manager mapping.
	 */
	setPaymentManagers(value: InitializedManagersMap): void;
	setCardNetworks(value: CardNetworksContext): void;
	setVaultManager(value: VaultManagerContext): void;
	setKlarnaCategories(value: KlarnaCategoriesContext): void;
	setClientOptions(value: PrimerCheckoutOptions | null): void;
	setHeadlessUtils(value: HeadlessUnitilsContext): void;
	setComputedStyles(value: CSSStyleDeclaration): void;
	setVaultManagerCvv(value: VaultItemContext): void;
}
export type SdkStateAction = {
	type: "START_PROCESSING";
} | {
	type: "START_LOADING";
} | {
	type: "COMPLETE_PROCESSING";
} | {
	type: "STOP_PROCESSING";
} | {
	type: "SET_ERROR";
	payload: Error;
} | {
	type: "SET_FAILURE";
	payload: {
		code: string;
		message: string;
		details?: Record<string, unknown>;
	};
} | {
	type: "COMPLETE_LOADING";
} | {
	type: "RESET";
} | {
	type: "RESET_ERROR";
};
declare class SdkStateController extends ReactiveStateController<PrimerCheckoutType, SdkState, SdkStateAction, null> {
	constructor(host: PrimerCheckoutType);
	startLoading(): void;
	startProcessing(): void;
	stopProcessing(): void;
	completeProcessing(): void;
	completeLoading(): void;
	setError(error: Error): void;
	setFailure(code: string, message: string, details?: Record<string, unknown>): void;
	reset(): void;
	resetError(): void;
	forceCompleteLoading(): void;
}
export interface PrimerCheckoutType extends ReactiveControllerHost, LitElement {
	requestUpdate: ReactiveControllerHost["requestUpdate"];
	customStyles: string;
	clientToken: string;
	options: PrimerCheckoutOptions;
	sdkContextController: SDKContextController;
	sdkStateController: SdkStateController;
	primerEventsController: PrimerEventsController;
	vaultManagerController: VaultManagerController;
	cardNetworkController: CardNetworkController;
}
declare class CardNetworkController implements ReactiveController {
	private host;
	constructor(host: PrimerCheckoutType);
	hostConnected(): void;
	/**
	 * Sets the card networks to loading state
	 */
	setCardNetworksLoading(): void;
	/**
	 * Updates card networks state and dispatches events
	 *
	 * @param cardNetworks - The new card networks context
	 */
	private updateCardNetworksState;
	/**
	 * Processes a card network change event
	 *
	 * @param event - The card network change event
	 */
	processCardNetworkChangeEvent(event: CardNetworkChangeEvent): Promise<void>;
}
declare class StyleProcessingController implements ReactiveController {
	host: ReactiveControllerHost & LitElement;
	private static cssVarCache;
	constructor(host: ReactiveControllerHost & LitElement);
	/**
	 * Processes the customStyles JSON string.
	 * Expected JSON contains only CSS variable properties in camelCase.
	 * @param jsonString The JSON string representing custom styles.
	 */
	processCustomStyles(jsonString: string): void;
	/**
	 * Validates a CSS property name to ensure it follows expected patterns.
	 * @param property The CSS property name to validate.
	 * @returns boolean True if the property name is considered valid.
	 */
	private isValidCssProperty;
	/**
	 * Validates a CSS value to ensure it only contains safe, expected characters.
	 * Allowed characters include alphanumerics, whitespace, and common CSS punctuation.
	 * This helps prevent CSS injection attacks.
	 *
	 * @param value The CSS value to validate.
	 * @returns boolean True if the value is considered valid.
	 */
	private isValidCssValue;
	/**
	 * Gets the CSS variable name for a camelCase property key.
	 * Uses caching for performance.
	 *
	 * @param key The camelCase property key
	 * @returns The CSS variable name (kebab-case with -- prefix)
	 */
	private getCssVarName;
	/**
	 * Transforms a styles object into CSS variables and applies them to the host element.
	 * Each key (in camelCase) is converted into a kebab-case CSS variable prefixed with '--'.
	 * Only valid CSS properties and values are applied.
	 *
	 * @param styles An object with style keys and corresponding CSS values.
	 */
	private applyStyles;
	/**
	 * Removes a specific CSS variable from the host element
	 * @param key The camelCase property key to remove
	 */
	removeStyle(key: string): void;
	/**
	 * Removes all custom styles from the host element
	 */
	clearAllStyles(): void;
	/**
	 * Optional cleanup when the host is disconnected
	 */
	hostDisconnected(): void;
}
declare const sourceLocale = `en`;
declare const targetLocales = [
	`ar`,
	`bg`,
	`ca`,
	`cs`,
	`da`,
	`de`,
	`el`,
	`en-GB`,
	`es`,
	`es-AR`,
	`es-MX`,
	`et-EE`,
	`fi-FI`,
	`fr`,
	`he`,
	`hr`,
	`hu`,
	`id`,
	`it`,
	`ja`,
	`ko`,
	`lt`,
	`lt-LT`,
	`lv`,
	`lv-LV`,
	`ms`,
	`nb`,
	`nl`,
	`nl_NL`,
	`pl`,
	`pt`,
	`pt-BR`,
	`ro`,
	`ru`,
	`sk`,
	`sl`,
	`sr-RS`,
	`sv`,
	`th`,
	`tr`,
	`uk-UA`,
	`vi`,
	`zf`,
	`zh-CN`,
	`zh-HK`,
	`zh-TW`,
] as const;
export type LocaleCode = typeof sourceLocale | (typeof targetLocales)[number];
declare class AchPaymentEventsController implements ReactiveController {
	host: PrimerCheckoutComponent;
	constructor(host: PrimerCheckoutComponent);
	private _error;
	private _mandateConfirmed;
	private _mandateDeclined;
	hostConnected(): void;
	hostDisconnected(): void;
}
/**
 * PrimerCheckoutComponent implements the main checkout experience.
 * This component includes a CSS-only loader that displays before the JavaScript
 * is fully loaded, ensuring users see a loading indicator immediately.
 *
 * The loader can be disabled by:
 * 1. Adding the 'loader-disabled' attribute to the component
 * 2. Setting the CSS custom property --primer-loader-disabled: 1
 */
export declare class PrimerCheckoutComponent extends LitElement implements PrimerCheckoutType {
	set jsInitialized(value: boolean);
	get jsInitialized(): boolean;
	static styles: CSSResult[];
	customStyles: string;
	clientToken: string;
	options: PrimerCheckoutOptions;
	/**
	 * Whether the component has completed initialization and loading
	 * This is used to control the CSS-only loader visibility
	 * @private
	 */
	private _jsInitialized;
	defaultSlot: HTMLSlotElement;
	private previousLoadingState;
	private hasAssignedContent;
	private _loadingTimeoutId;
	locale?: LocaleCode;
	private onSlotChange;
	sdkContextController: SDKContextController;
	sdkStateController: SdkStateController;
	primerEventsController: PrimerEventsController;
	styleProcessingController: StyleProcessingController;
	vaultManagerController: VaultManagerController;
	cardNetworkController: CardNetworkController;
	achPaymentEventsController: AchPaymentEventsController;
	constructor();
	attributeChangedCallback(attrName: string, oldVal: string, newVal: string): void;
	disconnectedCallback(): void;
	willUpdate(changedProperties: PropertyValues): void;
	updated(): void;
	/**
	 * Check if the loading state has changed and update the CSS loader visibility accordingly.
	 * This method is called after each update cycle to detect when loading is complete.
	 */
	private checkLoadingStateChange;
	render(): TemplateResult;
	addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: PrimerCheckoutComponent, ev: HTMLElementEventMap[K]) => void, options?: boolean | AddEventListenerOptions): void;
	addEventListener<K extends keyof ShadowRootEventMap>(type: K, listener: (this: PrimerCheckoutComponent, ev: ShadowRootEventMap[K]) => void, options?: boolean | AddEventListenerOptions): void;
	addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: PrimerCheckoutComponent, ev: DocumentEventMap[K]) => void, options?: boolean | AddEventListenerOptions): void;
	addEventListener<K extends keyof PrimerEvents>(type: K, listener: (this: PrimerCheckoutComponent, ev: PrimerEvents[K]) => void, options?: boolean | AddEventListenerOptions): void;
	removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: PrimerCheckoutComponent, ev: HTMLElementEventMap[K]) => void, options?: boolean | EventListenerOptions): void;
	removeEventListener<K extends keyof ShadowRootEventMap>(type: K, listener: (this: PrimerCheckoutComponent, ev: ShadowRootEventMap[K]) => void, options?: boolean | EventListenerOptions): void;
	removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: PrimerCheckoutComponent, ev: DocumentEventMap[K]) => void, options?: boolean | EventListenerOptions): void;
	removeEventListener<K extends keyof PrimerEvents>(type: K, listener: (this: PrimerCheckoutComponent, ev: PrimerEvents[K]) => void, options?: boolean | EventListenerOptions): void;
}
/**
 * Injects the CSS loader styles into the page
 * These styles display a loading indicator before JavaScript initializes
 *
 * Unlike theme styles, loader styles should take precedence over merchant styles
 * to ensure the loading indicator is visible. We append them to the end of the head.
 */
export declare function injectLoaderStyles(): void;
/**
 * Injects all required theme CSS variables into the page
 * This should be called before components are rendered to ensure
 * they have access to all design tokens
 *
 * Theme styles are prepended to the document head to allow merchant styles
 * to override our default variables.
 */
export declare function injectThemeStyles(): void;
/**
 * Utility function to inject only the light theme CSS variables
 * @returns {void}
 */
export declare function injectLightTheme(): void;
/**
 * Utility function to inject only the dark theme CSS variables
 * @returns {void}
 */
export declare function injectDarkTheme(): void;
/**
 * Size options for the spinner component
 */
export type SpinnerSize = "small" | "medium" | "large";
/**
 * Spinner component with configurable size and color
 * Adapted to work both standalone and within input components
 */
declare class SpinnerComponent extends LitElement {
	/**
	 * Color of the spinner
	 * Defaults to the design system loader color
	 */
	color: string;
	/**
	 * Size of the spinner
	 * Available values: 'small', 'medium', 'large' or a custom number as string
	 */
	size: SpinnerSize | string;
	/**
	 * Whether to use compact mode (minimal margins)
	 * Useful when embedding in inputs
	 */
	compact: boolean;
	static styles: CSSResult[];
	/**
	 * Get the actual size value in pixels
	 */
	private getSize;
	render(): TemplateResult<1>;
}
declare global {
	interface HTMLElementTagNameMap {
		"primer-spinner": SpinnerComponent;
	}
}
/**
 * A wrapper component for input elements that handles focus styling and interactions.
 * Provides an improved user experience by making the entire wrapper clickable to focus the inner input.
 *
 * Features:
 * - Automatically focuses primer-input elements when wrapper is clicked
 * - Dispatches wrapper-click events for iframe-based hosted inputs
 * - Sets proper cursor styling to indicate text input functionality
 */
declare class InputWrapperComponent extends LitElement {
	static styles: CSSResult[];
	focusWithin: boolean;
	hasError: boolean;
	private inputSlot;
	/**
	 * Event handler for click events on the input slot wrapper.
	 * Does one of the following:
	 * 1. If a primer-input is found inside, focus it directly
	 * 2. Otherwise, dispatch a wrapper-click event for hosted inputs to handle
	 */
	private handleWrapperClick;
	/**
	 * Finds the first primer-input element inside the input slot
	 * @returns The primer-input element or null if not found
	 */
	private findSlottedPrimerInput;
	render(): TemplateResult<1>;
}
declare global {
	interface HTMLElementTagNameMap {
		"primer-input-wrapper": InputWrapperComponent;
	}
}
/**
 * Input label component for form elements
 *
 * @element primer-input-label
 * @slot - Default slot for label text content
 */
declare class InputLabelComponent extends LitElement {
	static styles: CSSResult[];
	/**
	 * ID of the form control this label is associated with
	 */
	for: string;
	/**
	 * Whether the label should appear disabled
	 */
	disabled: boolean;
	render(): TemplateResult<1>;
}
declare global {
	interface HTMLElementTagNameMap {
		"primer-input-label": InputLabelComponent;
	}
}
/**
 * Simplified selection state for buttons
 */
export type ButtonSelectionState = "default" | "checked";
declare class ButtonComponent extends LitElement {
	static styles: CSSResult[];
	variant: "primary" | "secondary" | "tertiary";
	disabled: boolean;
	/**
	 * Loading state of the button
	 * When true, the button will display a spinner and be disabled
	 */
	loading: boolean;
	buttonType: "button" | "submit" | "reset";
	/**
	 * Selection state of the button
	 * - default: Not checked
	 * - checked: Button is checked
	 */
	selectionState: ButtonSelectionState;
	/**
	 * Indicates if this button is selectable/checkable
	 */
	selectable: boolean;
	/**
	 * Event handler for button click
	 * If selectable, it will toggle between checked and default states
	 */
	private handleClick;
	/**
	 * Renders the checkmark icon when checked
	 */
	private renderCheckmark;
	/**
	 * Renders the spinner when in loading state
	 */
	private renderSpinner;
	render(): TemplateResult<1>;
}
declare global {
	interface HTMLElementTagNameMap {
		"primer-button": ButtonComponent;
	}
}
/**
 * Input error component for displaying form validation messages
 *
 * @element primer-input-error
 * @slot - Default slot for error message content
 */
declare class InputErrorComponent extends LitElement {
	static styles: CSSResult[];
	/**
	 * ID of the form control this error message is associated with
	 */
	for: string;
	/**
	 * Whether the error is currently active/visible
	 */
	active: boolean;
	render(): TemplateResult<1>;
}
declare global {
	interface HTMLElementTagNameMap {
		"primer-input-error": InputErrorComponent;
	}
}
export type IconName = keyof typeof icons;
declare const icons: Record<string, SVGTemplateResult>;
declare class PrimerIconComponent extends LitElement {
	static styles: CSSResult[];
	color: string;
	size: "lg" | "md" | "sm";
	/** The name of the icon to draw - available names can be found under library.ts file */
	name?: IconName;
	render(): TemplateResult<1>;
}
declare global {
	interface HTMLElementTagNameMap {
		"primer-icon": PrimerIconComponent;
	}
}
declare class PrimerCheckoutStateComponent extends LitElement {
	static styles: CSSResult[];
	type: "complete" | "failure";
	description?: string;
	render(): TemplateResult<1>;
}
declare global {
	interface HTMLElementTagNameMap {
		"primer-checkout-state": PrimerCheckoutStateComponent;
	}
}
/**
 * Input types supported by this component
 */
export type InputType = "text" | "password" | "email" | "number" | "tel" | "url" | "search" | "date" | "time" | "datetime-local" | "month" | "week" | "color";
/**
 * Custom events dispatched by this component
 */
export type InputEventMap = {
	input: CustomEvent<string>;
	change: CustomEvent<string>;
	focus: FocusEvent;
	blur: FocusEvent;
	invalid: Event;
};
/**
 * A fully type-safe input component that wraps the native HTML input element
 * while providing additional functionality and styling.
 *
 * @element primer-input
 *
 * @fires input - Fired when the input value changes
 * @fires change - Fired when the input value is committed
 * @fires focus - Fired when the input receives focus
 * @fires blur - Fired when the input loses focus
 * @fires invalid - Fired when the input fails validation
 *
 * @csspart input - The native input element
 */
declare class InputComponent extends LitElement {
	static styles: CSSResult[];
	private inputElement;
	value: string;
	placeholder: string;
	disabled: boolean;
	name: string;
	type: InputType;
	required: boolean;
	readonly: boolean;
	pattern: string;
	minlength?: number;
	maxlength?: number;
	min: string;
	max: string;
	step: string;
	autocomplete: string;
	id: string;
	private hasFocus;
	private hasError;
	/**
	 * Handles input events and dispatches a custom event with the current value
	 */
	private handleInput;
	/**
	 * Handles change events and dispatches a custom event with the committed value
	 */
	private handleChange;
	/**
	 * Handles focus events and updates internal state
	 */
	private handleFocus;
	/**
	 * Handles blur events and updates internal state
	 */
	private handleBlur;
	/**
	 * Handles invalid events and updates internal state
	 */
	private handleInvalid;
	/**
	 * Focus the input element
	 * @param options Optional focus options
	 */
	focus(options?: FocusOptions): void;
	/**
	 * Remove focus from the input element
	 */
	blur(): void;
	/**
	 * Select all text in the input element
	 */
	select(): void;
	/**
	 * Set the selection range of the input element
	 */
	setSelectionRange(start: number, end: number, direction?: "forward" | "backward" | "none"): void;
	/**
	 * Get the validity state of the input element
	 */
	get validity(): ValidityState;
	/**
	 * Get the validation message of the input element
	 */
	get validationMessage(): string;
	/**
	 * Check if the input element is valid
	 */
	checkValidity(): boolean;
	/**
	 * Report the validity of the input element
	 */
	reportValidity(): boolean;
	render(): TemplateResult<1>;
	/**
	 * Type safe event dispatcher - allows consumers to use proper types
	 * when listening to events from this component
	 */
	addEventListener<K extends keyof InputEventMap>(type: K, listener: (ev: InputEventMap[K]) => void, options?: boolean | AddEventListenerOptions): void;
	/**
	 * Type safe event dispatcher removal
	 */
	removeEventListener<K extends keyof InputEventMap>(type: K, listener: (ev: InputEventMap[K]) => void, options?: boolean | EventListenerOptions): void;
}
declare global {
	interface HTMLElementTagNameMap {
		"primer-input": InputComponent;
	}
}
/**
 * Event detail interface for expanded-changed event
 */
export interface ExpandedChangedDetail {
	expanded: boolean;
}
/**
 * Button variant types
 */
export type ButtonVariant = "primary" | "secondary" | "tertiary";
/**
 * A collapsable component that smoothly expands and collapses content.
 * Uses CSS Grid for smooth animation and incorporates the primary button.
 */
declare class CollapsableComponent extends LitElement {
	static styles: CSSResult[];
	/**
	 * The header text for the collapsable
	 */
	header: string;
	/**
	 * Whether the collapsable is expanded by default
	 */
	expanded: boolean;
	/**
	 * Text for expand button (for accessibility)
	 */
	expandText: string;
	/**
	 * Text for collapse button (for accessibility)
	 */
	collapseText: string;
	/**
	 * ARIA label for the collapsable header
	 */
	ariaLabel: string;
	/**
	 * The button variant to use
	 */
	buttonVariant: ButtonVariant;
	/**
	 * Internal state to track expanded state
	 */
	private isExpanded;
	/**
	 * Hook into the component lifecycle to set the initial expanded state
	 */
	connectedCallback(): void;
	/**
	 * Dispatch the expanded-changed event
	 */
	private dispatchExpandedChangedEvent;
	/**
	 * Toggle the expanded state
	 */
	private toggleExpanded;
	/**
	 * Expand the collapsable programmatically
	 */
	expand(): void;
	/**
	 * Collapse the collapsable programmatically
	 */
	collapse(): void;
	render(): TemplateResult<1>;
}
declare global {
	interface HTMLElementTagNameMap {
		"primer-collapsable": CollapsableComponent;
	}
}
/**
 * A reusable atomic error message component that displays error information
 * with appropriate styling and accessibility attributes.
 *
 * This component is fully accessible and designed to work with screen readers.
 * It includes animations for visibility transitions.
 *
 * @element primer-error-message
 *
 * @attr {string} message - The error message text to display
 * @attr {boolean} visible - Whether the error message is visible
 * @attr {string} role - Accessibility role (defaults to "alert")
 *
 * @csspart error-message - The main error message container
 * @csspart error-icon - The error icon container
 * @csspart error-content - The error text content
 */
declare class ErrorMessageComponent extends LitElement {
	static styles: CSSResult[];
	/**
	 * The error message text to display
	 */
	message: string;
	/**
	 * Whether the error message is visible
	 */
	visible: boolean;
	/**
	 * Accessibility role for the error message
	 * Defaults to "alert" for proper screen reader announcements
	 */
	role: string;
	/**
	 * Internal state to track animation state
	 * This helps manage proper animations with DOM presence/absence
	 */
	private showMessage;
	protected updated(changedProperties: Map<PropertyKey, unknown>): void;
	/**
	 * Handle visibility changes with proper animation timing
	 */
	private handleVisibilityChange;
	render(): typeof nothing | TemplateResult<1>;
}
declare global {
	interface HTMLElementTagNameMap {
		"primer-error-message": ErrorMessageComponent;
	}
}
declare class PortalComponent extends LitElement {
	static styles: CSSResult[];
	id: string;
	getContainer(): HTMLDivElement;
	/**
	 * Proxies the events sent from the portalled content and
	 * re-dispatches them.
	 *
	 * TODO: find a better way to scale to new events instead
	 * of hardcoding them one by one here.
	 */
	private _setupEventListeners;
	disconnectedCallback(): void;
	private _handleSlotChange;
	render(): TemplateResult<1>;
}
declare global {
	interface HTMLElementTagNameMap {
		"primer-portal": PortalComponent;
	}
}
declare class DialogComponent extends LitElement {
	static styles: CSSResult[];
	private _handleCloseClick;
	render(): TemplateResult<1>;
}
declare global {
	interface HTMLElementTagNameMap {
		"primer-dialog": DialogComponent;
	}
}
/**
 * This component renders Klarna payment method in a card-like (accordion) container with
 * payment categories options to choose from.
 *
 * [ Pay with Klarna    v ] --> accordion header
 *
 * [ Pay Now ] [ Buy now, pay later ] --> payment categories options from Klarna
 * [ Continue with Klarna ] --> opens a Klarna popup
 */
declare class PrimerKlarnaComponent extends LitElement {
	static styles: CSSResult[];
	paymentManagers: InitializedManagersMap;
	sdkState: SdkStateContext;
	headlessUtils: HeadlessUnitilsContext;
	klarnaCategories: KlarnaCategoriesContext | null;
	private selectedCategory;
	private isExpanded;
	private headerAriaLabel;
	private klarnaContainer;
	private _paymentMethodManagerTask;
	toggleExpand(): void;
	startKlarnaPayment(): Promise<void>;
	renderSelectedCategory(): Promise<void>;
	selectCategory(category: string): void;
	updated(changedProperties: Map<string, unknown>): void;
	renderCategorySelection(): TemplateResult<1>;
	renderExpandedContent(): TemplateResult<1>;
	render(): typeof nothing | TemplateResult<1> | undefined;
}
declare global {
	interface HTMLElementTagNameMap {
		"primer-klarna": PrimerKlarnaComponent;
	}
}
export type PaymentMethodsContext = InitializedPayments | null;
declare class PaymentMethodComponent extends LitElement {
	static styles: CSSResult[];
	type: PaymentMethodType$1 | undefined;
	paymentMethods: PaymentMethodsContext;
	render(): typeof nothing | TemplateResult<1>;
}
declare global {
	interface HTMLElementTagNameMap {
		"primer-payment-method": PaymentMethodComponent;
	}
}
export type ClientOptionsContext = PrimerCheckoutOptions | null;
export type AchField = "firstName" | "lastName" | "emailAddress";
export interface AchFormState {
	value: string;
	error: string;
	pristine: boolean;
	touched: boolean;
	dirty: boolean;
	valid: boolean;
}
export type AchFormStateMap = Record<AchField, AchFormState>;
export type ValidationFunction = (data: StripeAchCustomerDetails) => Promise<Validation>;
declare class AchPaymentFormControler implements ReactiveController {
	host: AchPaymentComponent;
	validate: ValidationFunction;
	formState: AchFormStateMap;
	get hasError(): {
		firstName: boolean;
		lastName: boolean;
		emailAddress: boolean;
	};
	get formData(): StripeAchCustomerDetails;
	constructor(host: AchPaymentComponent, validate: ValidationFunction);
	setFieldValue(field: AchField, value: string): Promise<void>;
	setValidation(validation: Validation, submit?: boolean): void;
	setFieldTouched(field: AchField): void;
	resetForm(): void;
	private isValidFieldName;
	hostConnected(): void;
	hostDisconnected(): void;
}
declare class AchPaymentComponent extends LitElement {
	static styles: CSSResult[];
	protected readonly formController: AchPaymentFormControler;
	paymentMethod: InitializedPaymentMethod | undefined;
	paymentManagers: InitializedManagersMap;
	sdkState: SdkStateContext | undefined;
	clientOptions: ClientOptionsContext | undefined;
	screen: "form" | "mandate";
	private isSubmitting;
	private _paymentMethodManagerTask;
	private _handleInput;
	private _handleBlur;
	private _handleError;
	private _handleSubmitButtonClick;
	private _handleCollectBankAccountDetails;
	private _handleConfirmMandate;
	private _handleDeclineMandate;
	private renderForm;
	private renderMandate;
	render(): TemplateResult | typeof nothing | undefined;
}
declare global {
	interface HTMLElementTagNameMap {
		"primer-ach-payment": AchPaymentComponent;
	}
}
declare class DynamicPaymentComponent extends LitElement {
	static styles: CSSResult[];
	paymentMethod: InitializedPaymentMethod | undefined;
	paymentManagers: InitializedManagersMap;
	sdkState: SdkStateContext;
	headlessUtils: HeadlessUnitilsContext;
	open: boolean;
	private _paymentMethodManagerTask;
	private _getAssetsTask;
	/**
	 * Based on packages/primer-sdk-web/src/payment-methods/Button.tsx
	 * Should be replaced once we align on a better solution across all platforms.
	 * TODO: get label from payment config
	 */
	private _legacyGetButtonLabel;
	private _setupTasks;
	start(): void;
	renderDialog(): typeof nothing | TemplateResult<1>;
	render(): symbol | TemplateResult<1> | undefined;
}
declare global {
	interface HTMLElementTagNameMap {
		"primer-dynamic-payment": DynamicPaymentComponent;
	}
}
declare class RedirectPaymentComponent extends LitElement {
	static styles: CSSResult[];
	paymentMethod: InitializedPaymentMethod | undefined;
	paymentManagers: InitializedManagersMap;
	sdkState: SdkStateContext;
	headlessUtils: HeadlessUnitilsContext;
	private _paymentMethodManagerTask;
	/**
	 * Based on packages/primer-sdk-web/src/payment-methods/Button.tsx
	 * Should be replaced once we align on a better solution across all platforms.
	 */
	private _legacyGetButtonLabel;
	private _getAssetsTask;
	private _setupTasks;
	startRedirectPayment(): void;
	render(): symbol | TemplateResult<1> | undefined;
}
declare global {
	interface HTMLElementTagNameMap {
		"primer-redirect-payment": RedirectPaymentComponent;
	}
}
/**
 * Events emitted by the vault manager components
 */
export interface VaultManagerEvents {
	deletePaymentMethod: CustomEvent<string>;
	cancelDelete: CustomEvent<void>;
	confirmDelete: CustomEvent<void>;
	toggleEditMode: CustomEvent<boolean>;
	closeError: CustomEvent<void>;
	vaultPaymentError: CustomEvent<{
		error: Error | unknown;
	}>;
}
/**
 * Declare the event map for strict typing of events
 */
export interface VaultManagerEventMap {
	"delete-payment-method": VaultManagerEvents["deletePaymentMethod"];
	"cancel-delete": VaultManagerEvents["cancelDelete"];
	"confirm-delete": VaultManagerEvents["confirmDelete"];
	"toggle-edit-mode": VaultManagerEvents["toggleEditMode"];
	"close-error": VaultManagerEvents["closeError"];
	"primer-vault-payment-error": VaultManagerEvents["vaultPaymentError"];
}
/**
 * VaultManagerComponent - displays and manages saved payment methods
 */
declare class VaultManagerComponent extends LitElement {
	static styles: CSSResult[];
	constructor();
	addEventListener: <K extends keyof VaultManagerEventMap>(type: K, listener: (ev: VaultManagerEventMap[K]) => void, options?: boolean | AddEventListenerOptions) => void;
	removeEventListener: <K extends keyof VaultManagerEventMap>(type: K, listener: (ev: VaultManagerEventMap[K]) => void, options?: boolean | AddEventListenerOptions) => void;
	vaultManagerContext: VaultManagerContext;
	/**
	 * Whether we're in edit mode
	 */
	private isEditMode;
	/**
	 * Payment method being deleted
	 */
	private deletePaymentMethodId;
	/**
	 * Whether a delete operation is in progress
	 */
	private isDeleting;
	/**
	 * Error message if something goes wrong
	 */
	private errorMessage;
	/**
	 * Animation duration override
	 */
	animationDuration: number;
	/**
	 * Get base animation configuration with current settings
	 */
	private getAnimationConfig;
	/**
	 * Toggle edit mode handler
	 */
	private handleToggleEditMode;
	/**
	 * Handle delete click from payment method item
	 */
	private handleDeletePaymentMethod;
	/**
	 * Cancel delete operation
	 */
	private handleCancelDelete;
	/**
	 * Confirm and process payment method deletion
	 */
	private handleConfirmDelete;
	/**
	 * Handle payment error events
	 */
	private handlePaymentError;
	/**
	 * Handle closing error message
	 */
	private handleCloseError;
	/**
	 * Get payment method display name for the given ID
	 */
	private getPaymentMethodName;
	/**
	 * Render loading overlay with spinner when isUpdating is true
	 */
	private renderLoadingOverlay;
	/**
	 * Render delete confirmation content
	 */
	private renderDeleteConfirmation;
	/**
	 * Render a payment method item with appropriate animations
	 */
	private renderPaymentMethodItem;
	/**
	 * Render the payment method list with submit button
	 */
	private renderPaymentMethodList;
	/**
	 * Main render method
	 */
	render(): typeof nothing | TemplateResult<1>;
}
/**
 * VaultPaymentMethodItemComponent - displays a single payment method
 * Uses the VaultManagerController for display formatting
 * Now supports selection via the simplified button checked state
 * Enhanced with smooth transitions between edit and payment modes
 * Always renders the primer-button for consistent UI and improved accessibility
 */
declare class VaultPaymentMethodItemComponent extends LitElement {
	static styles: CSSResult[];
	/**
	 * Strongly typed event declarations
	 */
	addEventListener: <K extends keyof VaultManagerEventMap>(type: K, listener: (ev: VaultManagerEventMap[K]) => void, options?: boolean | AddEventListenerOptions) => void;
	removeEventListener: <K extends keyof VaultManagerEventMap>(type: K, listener: (ev: VaultManagerEventMap[K]) => void, options?: boolean | AddEventListenerOptions) => void;
	/**
	 * Consume the vault manager context
	 */
	vaultManagerContext: VaultManagerContext;
	vaultItemContext: VaultItemContext;
	headlessUtils: HeadlessUnitilsContext;
	/**
	 * The payment method to display
	 */
	paymentMethod: VaultedPaymentMethod | null;
	/**
	 * Whether the component is in edit mode
	 */
	isEditMode: boolean;
	private _getAssetsTask;
	/**
	 * Check if this payment method is currently selected in the context
	 */
	private isSelected;
	/**
	 * Handle when the button is clicked
	 * This is used to select the payment method and deselect others
	 */
	private handleClick;
	/**
	 * Dispatch delete event
	 */
	private handleDeleteClick;
	/**
	 * Builds the common content template shared between modes
	 */
	private renderPaymentMethodContent;
	/**
	 * Render method
	 */
	render(): symbol | TemplateResult<1> | undefined;
}
declare global {
	interface HTMLElementTagNameMap {
		"primer-vault-payment-method-item": VaultPaymentMethodItemComponent;
	}
}
/**
 * VaultManagerHeaderComponent - displays the header for the vault manager
 */
declare class VaultManagerHeaderComponent extends LitElement {
	static styles: CSSResult[];
	/**
	 * Strongly typed event declarations
	 */
	addEventListener: <K extends keyof VaultManagerEventMap>(type: K, listener: (ev: VaultManagerEventMap[K]) => void, options?: boolean | AddEventListenerOptions) => void;
	removeEventListener: <K extends keyof VaultManagerEventMap>(type: K, listener: (ev: VaultManagerEventMap[K]) => void, options?: boolean | AddEventListenerOptions) => void;
	/**
	 * Whether we're in edit mode
	 */
	isEditMode: boolean;
	/**
	 * Whether we have payment methods to edit
	 */
	hasPaymentMethods: boolean;
	/**
	 * Toggle edit mode
	 */
	private toggleEditMode;
	/**
	 * Render method
	 */
	protected render(): TemplateResult<1>;
}
declare global {
	interface HTMLElementTagNameMap {
		"primer-vault-manager-header": VaultManagerHeaderComponent;
	}
}
/**
 * VaultDeleteConfirmationComponent - displays confirmation UI for deleting a payment method
 */
declare class VaultDeleteConfirmationComponent extends LitElement {
	static styles: CSSResult[];
	/**
	 * Strongly typed event declarations
	 */
	addEventListener: <K extends keyof VaultManagerEventMap>(type: K, listener: (ev: VaultManagerEventMap[K]) => void, options?: boolean | AddEventListenerOptions) => void;
	removeEventListener: <K extends keyof VaultManagerEventMap>(type: K, listener: (ev: VaultManagerEventMap[K]) => void, options?: boolean | AddEventListenerOptions) => void;
	/**
	 * Whether a delete operation is in progress
	 */
	isDeleting: boolean;
	/**
	 * The ID of the payment method being deleted
	 */
	paymentMethodId: string;
	/**
	 * Payment method name to display in confirmation
	 */
	paymentMethodName: string;
	/**
	 * Consume the vault manager context to access payment method info
	 */
	vaultManager: VaultManagerContext;
	/**
	 * Handle confirm click
	 */
	private handleConfirmClick;
	/**
	 * Handle cancel click
	 */
	private handleCancelClick;
	/**
	 * Render method
	 */
	protected render(): TemplateResult<1>;
}
declare global {
	interface HTMLElementTagNameMap {
		"primer-vault-delete-confirmation": VaultDeleteConfirmationComponent;
	}
}
/**
 * VaultEmptyStateComponent - displays when no payment methods are available
 */
declare class VaultEmptyStateComponent extends LitElement {
	static styles: CSSResult[];
	/**
	 * Render method
	 */
	protected render(): TemplateResult<1>;
}
declare global {
	interface HTMLElementTagNameMap {
		"primer-vault-empty-state": VaultEmptyStateComponent;
	}
}
/**
 * VaultErrorMessageComponent - displays error messages with improved visuals
 */
declare class VaultErrorMessageComponent extends LitElement {
	static styles: CSSResult[];
	/**
	 * Strongly typed event declarations
	 */
	addEventListener: <K extends keyof VaultManagerEventMap>(type: K, listener: (ev: VaultManagerEventMap[K]) => void, options?: boolean | AddEventListenerOptions) => void;
	removeEventListener: <K extends keyof VaultManagerEventMap>(type: K, listener: (ev: VaultManagerEventMap[K]) => void, options?: boolean | AddEventListenerOptions) => void;
	/**
	 * The error message to display
	 */
	errorMessage: string;
	/**
	 * Handle dismiss click
	 */
	private handleDismiss;
	/**
	 * Render method
	 */
	protected render(): TemplateResult<1>;
}
declare global {
	interface HTMLElementTagNameMap {
		"primer-vault-error-message": VaultErrorMessageComponent;
	}
}
/**
 * A submit button component for vault payment flows.
 * Provides a consistent submit button with translation support.
 * Integrates with the vault manager context to handle payment submission.
 */
declare class VaultPaymentSubmitComponent extends LitElement {
	static styles: CSSResult[];
	private readonly _userAssignedProps;
	private _internalButtonText;
	/**
	 * The button text to display.
	 * Falls back to localized default if not explicitly set.
	 */
	get buttonText(): string;
	set buttonText(value: string);
	headlessInstance: HeadlessUnitilsContext;
	sdkState: SdkStateContext;
	vaultItemContext: VaultItemContext;
	vaultManager: VaultManagerContext;
	clientOptions: PrimerCheckoutOptions | null;
	/**
	 * The button variant to use.
	 * @default "primary"
	 */
	variant: string;
	/**
	 * Whether the button is disabled.
	 * This property allows external disabling of the button
	 * regardless of the context state.
	 * @default false
	 */
	disabled: boolean;
	/**
	 * Handle button click event.
	 * Prevents default form submission and triggers the vault payment flow.
	 */
	private handleClick;
	/**
	 * Computed property to determine if the button should be disabled
	 */
	private get isButtonDisabled();
	render(): TemplateResult<1>;
}
declare global {
	interface HTMLElementTagNameMap {
		"primer-vault-payment-submit": VaultPaymentSubmitComponent;
	}
}
/**
 * CVV Input component for vault payment methods
 * Renders a secure iframe for CVV input when required by the selected payment method
 * Uses dedicated CVV context to minimize re-renders
 */
declare class VaultCvvInputComponent extends LitElement {
	static styles: CSSResult[];
	/**
	 * Form context for checking form dirty state
	 */
	vaultManagerFormContext: VaultManagerContext;
	/**
	 * CVV-specific context for dedicated CVV handling
	 * Separated to minimize re-renders on frequent CVV input changes
	 */
	vaultManagerCvvContext: VaultItemContext;
	computedStyles: CSSStyleDeclaration | null;
	paymentMethod: PaymentCardVaultedMethod | null;
	private cvvError;
	private cvvInputIsDirty;
	private cvvInputIsBlurred;
	private cvvInput;
	/**
	 * Unique ID for the CVV input container
	 */
	private readonly cvvContainerId;
	private _setupCVVIframe;
	constructor();
	disconnectedCallback(): void;
	/**
	 * Update CVV metadata in the context when input changes
	 */
	onCvvInputChange(): void;
	onBlur(): void;
	/**
	 * Main render method
	 */
	protected render(): symbol | TemplateResult<1> | undefined;
}
declare global {
	interface HTMLElementTagNameMap {
		"primer-vault-cvv-input": VaultCvvInputComponent;
	}
}
declare global {
	interface HTMLElementTagNameMap {
		"primer-vault-manager": VaultManagerComponent;
	}
}
/**
 * CardFormComponent serves as a container for card input components.
 * It handles form submission, validation, and provides context to child components.
 */
declare class CardFormComponent extends LitElement {
	static styles: CSSResult[];
	hideLabels: boolean;
	updated(changedProperties: Map<string, unknown>): void;
	/**
	 * Tracks whether custom content has been provided via slot
	 */
	private hasAssignedContent;
	private selectedCardNetwork;
	/**
	 * Payment managers injected from context
	 */
	paymentManagers: InitializedManagersMap;
	/**
	 * Context provider for card form data
	 */
	private readonly cardFormProvider;
	/**
	 * Events controller for dispatching form events
	 */
	private readonly eventsController;
	/**
	 * Task to set up the card form with hosted inputs
	 */
	private readonly setupCardFormTask;
	connectedCallback(): void;
	disconnectedCallback(): void;
	/**
	 * Handles click events from slotted content.
	 * Supports both native <button> and custom <primer-button> elements.
	 */
	private handleSlotButtonClick;
	/**
	 * Handles direct submit events from child components
	 * This is a backup method to catch all possible submission events
	 */
	private handleDirectSubmit;
	/**
	 * Determines if a button is a submit button based on its attributes
	 */
	private isSubmitButton;
	/**
	 * Handles slot change events to detect custom content
	 */
	private onSlotChange;
	/**
	 * Handles the card form submission.
	 * Validates the form and dispatches either a submit success or errors event.
	 */
	private submitCardPayment;
	/**
	 * Event handler for form submission
	 * Handles both native form submissions and custom events
	 */
	private handleFormSubmit;
	render(): typeof nothing | TemplateResult<1>;
}
export interface CardFormContext {
	cardNumberInput: IHeadlessHostedInput;
	expiryInput: IHeadlessHostedInput;
	cvvInput: IHeadlessHostedInput;
	setCardholderName: (val: string) => void;
	setCardNetwork: (val: string) => void;
	validate: () => Promise<Validation>;
	submit: (values?: CardPaymentMethodSubmitValues) => Promise<void>;
	errors?: Validation["validationErrors"];
	hideLabels?: boolean;
}
/**
 * A shared type that ensures the host of a HostedInputController contains
 * the required properties for proper hosted input handling.
 */
export interface HostedInputHost extends ReactiveControllerHost, LitElement {
	cardFormContext: CardFormContext | null;
	computedStyles: CSSStyleDeclaration | null;
	/** A string for the input placeholder. */
	placeholder: string;
	/** An accessible label for the input. */
	ariaLabel: string;
	/** The label for the input. */
	label: string;
	requestUpdate: ReactiveControllerHost["requestUpdate"];
}
export interface TaskFunctionOptions {
	signal: AbortSignal;
}
export type TaskFunction<D extends ReadonlyArray<unknown>, R = unknown> = (args: D, options: TaskFunctionOptions) => R | typeof initialState | Promise<R | typeof initialState>;
export type ArgsFunction<D extends ReadonlyArray<unknown>> = () => D;
declare const TaskStatus: {
	readonly INITIAL: 0;
	readonly PENDING: 1;
	readonly COMPLETE: 2;
	readonly ERROR: 3;
};
declare const initialState: unique symbol;
export type TaskStatus = (typeof TaskStatus)[keyof typeof TaskStatus];
export type StatusRenderer<R> = {
	initial?: () => unknown;
	pending?: () => unknown;
	complete?: (value: R) => unknown;
	error?: (error: unknown) => unknown;
};
export interface TaskConfig<T extends ReadonlyArray<unknown>, R> {
	task: TaskFunction<T, R>;
	args?: ArgsFunction<T>;
	/**
	 * Determines if the task is run automatically when arguments change after a
	 * host update. Default to `true`.
	 *
	 * If `true`, the task checks arguments during the host update (after
	 * `willUpdate()` and before `update()` in Lit) and runs if they change. For
	 * a task to see argument changes they must be done in `willUpdate()` or
	 * earlier. The host element can see task status changes caused by its own
	 * current update.
	 *
	 * If `'afterUpdate'`, the task checks arguments and runs _after_ the host
	 * update. This means that the task can see host changes done in update, such
	 * as rendered DOM. The host element can not see task status changes caused
	 * by its own update, so the task must trigger a second host update to make
	 * those changes renderable.
	 *
	 * Note: `'afterUpdate'` is unlikely to be SSR compatible in the future.
	 *
	 * If `false`, the task is not run automatically, and must be run with the
	 * {@linkcode run} method.
	 */
	autoRun?: boolean | "afterUpdate";
	/**
	 * A function that determines if the current arg and previous args arrays are
	 * equal. If the argsEqual function returns true, the task will not auto-run.
	 *
	 * The default is {@linkcode shallowArrayEquals}. {@linkcode deepArrayEquals}
	 * is also available.
	 */
	argsEqual?: (oldArgs: T, newArgs: T) => boolean;
	/**
	 * If initialValue is provided, the task is initialized to the COMPLETE
	 * status and the value is set to initialData.
	 *
	 * Initial args should be coherent with the initialValue, since they are
	 * assumed to be the args that would produce that value. When autoRun is
	 * `true` the task will not auto-run again until the args change.
	 */
	initialValue?: R;
	onComplete?: (value: R) => unknown;
	onError?: (error: unknown) => unknown;
}
declare class Task<const T extends ReadonlyArray<unknown> = ReadonlyArray<unknown>, const R = unknown> {
	private _previousArgs?;
	private _task;
	private _argsFn?;
	private _argsEqual;
	private _callId;
	private _host;
	private _value?;
	private _error?;
	private _abortController?;
	private _onComplete?;
	private _onError?;
	private _status;
	/**
	 * Determines if the task is run automatically when arguments change after a
	 * host update. Default to `true`.
	 *
	 * @see {@link TaskConfig.autoRun} for more information.
	 */
	autoRun: boolean | "afterUpdate";
	/**
	 * A Promise that resolve when the current task run is complete.
	 *
	 * If a new task run is started while a previous run is pending, the Promise
	 * is kept and only resolved when the new run is completed.
	 */
	get taskComplete(): Promise<R>;
	private _resolveTaskComplete?;
	private _rejectTaskComplete?;
	private _taskComplete?;
	constructor(host: ReactiveControllerHost, task: TaskConfig<T, R>);
	constructor(host: ReactiveControllerHost, task: TaskFunction<T, R>, args?: ArgsFunction<T>);
	hostUpdate(): void;
	hostUpdated(): void;
	private _getArgs;
	/**
	 * Determines if the task should run when it's triggered because of a
	 * host update, and runs the task if it should.
	 *
	 * A task should run when its arguments change from the previous run, based on
	 * the args equality function.
	 *
	 * This method is side-effectful: it stores the new args as the previous args.
	 */
	private _performTask;
	/**
	 * Runs a task manually.
	 *
	 * This can be useful for running tasks in response to events as opposed to
	 * automatically running when host element state changes.
	 *
	 * @param args an optional set of arguments to use for this task run. If args
	 *     is not given, the args function is called to get the arguments for
	 *     this run.
	 */
	run(args?: T): Promise<void>;
	/**
	 * Aborts the currently pending task run by aborting the AbortSignal
	 * passed to the task function.
	 *
	 * Aborting a task does nothing if the task is not running: ie, in the
	 * complete, error, or initial states.
	 *
	 * Aborting a task does not automatically cancel the task function. The task
	 * function must be written to accept the AbortSignal and either forward it
	 * to other APIs like `fetch()`, or handle cancellation manually by using
	 * [`signal.throwIfAborted()`]{@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/throwIfAborted}
	 * or the
	 * [`abort`]{@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/abort_event}
	 * event.
	 *
	 * @param reason The reason for aborting. Passed to
	 *     `AbortController.abort()`.
	 */
	abort(reason?: unknown): void;
	/**
	 * The result of the previous task run, if it resolved.
	 *
	 * Is `undefined` if the task has not run yet, or if the previous run errored.
	 */
	get value(): R | undefined;
	/**
	 * The error from the previous task run, if it rejected.
	 *
	 * Is `undefined` if the task has not run yet, or if the previous run
	 * completed successfully.
	 */
	get error(): unknown;
	get status(): TaskStatus;
	render<T extends StatusRenderer<R>>(renderer: T): MaybeReturnType<T["initial"]> | MaybeReturnType<T["pending"]> | MaybeReturnType<T["complete"]> | MaybeReturnType<T["error"]>;
}
export type MaybeReturnType<F> = F extends (...args: never[]) => infer R ? R : undefined;
/**
 * Available input types for hosted inputs.
 */
export type HostedInputType = "cardNumber" | "cvv" | "expire" | "cardholderName";
/**
 * Configuration for the hosted input controller.
 */
export interface HostedInputConfig {
	/** Differentiates the input type. */
	type: HostedInputType;
	/** Selector for the container element where the input should be rendered. */
	containerSelector: string;
	/**
	 * Optional callback for handling input events (e.g. for CardFormName).
	 */
	onInput?: (value: string) => void;
}
/**
 * Possible input source types that can be returned by getHostedInput
 */
export type InputSource = IHeadlessHostedInput | "cardholderName" | undefined;
declare class HostedInputController<T extends HostedInputHost> implements ReactiveController {
	private _isFocused;
	private _meta;
	private _hostedInput;
	private _standardInput;
	private readonly host;
	private readonly config;
	/**
	 * Task to set up the hosted input.
	 */
	readonly setupTask: Task<[
		InputSource
	], boolean | typeof initialState>;
	constructor(host: T, config: HostedInputConfig);
	/**
	 * Focuses the input, whether it's a hosted input or standard input
	 */
	focusInput(): void;
	/**
	 * Returns the hosted input from the card form context based on the type.
	 * For 'cardholderName', no hosted input is provided so we return a fallback indicator.
	 */
	private getHostedInput;
	/**
	 * Sets up the hosted input.
	 * If a hosted input is provided, it renders it into the target container.
	 * Otherwise (e.g. for cardholderName), it creates a standard input element.
	 */
	private setupHostedInput;
	/**
	 * Gets the target container element from the host's render root
	 */
	private getTargetContainer;
	/**
	 * Sets up a standard input element for non-hosted input types
	 */
	private setupStandardInput;
	/**
	 * Sets up event listeners for standard input elements
	 */
	private setupInputEventListeners;
	/**
	 * Sets up a hosted iframe input for iframe-based input types
	 */
	private setupHostedIframeInput;
	/** Exposes the current focus state. */
	get isFocused(): boolean;
	/** Exposes the current metadata state. */
	get meta(): InputMetadata;
	hostConnected(): void;
	hostDisconnected(): void;
}
/**
 * Translation configuration object
 */
export type TranslationConfig = {
	id: string;
	defaultMessage: string;
};
/**
 * Configuration for abstract input component
 */
export interface InputComponentConfig {
	/** The component's hosted input type */
	inputType: HostedInputType;
	/** ID selector for the container where the input will be rendered */
	containerSelector: string;
	/** Error name to match in the card form context */
	errorName: string;
	/** Translation keys for default values */
	translations: {
		label: TranslationConfig | string;
		placeholder?: TranslationConfig | string;
		ariaLabel?: TranslationConfig | string;
	};
	/** Optional input handler for non-hosted inputs */
	onInput?: (value: string) => void;
}
declare abstract class AbstractCardInputComponent extends LitElement implements HostedInputHost {
	cardFormContext: CardFormContext | null;
	computedStyles: CSSStyleDeclaration | null;
	/** Tracks which properties were explicitly set by the user */
	protected readonly _userAssignedProps: Set<string>;
	/** Internal storage for property values */
	protected _internalLabel: string;
	protected _internalPlaceholder: string;
	protected _internalAriaLabel: string;
	/** Configuration for this input component */
	protected abstract readonly config: InputComponentConfig;
	/** Hosted input controller */
	protected readonly hostedInputController: HostedInputController<HostedInputHost>;
	/**
	 * Gets a translated or static string value from the translation config
	 */
	private getTranslatedValue;
	/**
	 * The input label text.
	 * Falls back to localized default if not explicitly set.
	 */
	get label(): string;
	set label(value: string);
	/**
	 * The input placeholder text.
	 * Falls back to localized default if not explicitly set.
	 * When explicitly set to empty string, no placeholder will be displayed.
	 */
	get placeholder(): string;
	set placeholder(value: string);
	/**
	 * The input aria-label attribute.
	 * Falls back to localized default if not explicitly set.
	 */
	get ariaLabel(): string;
	set ariaLabel(value: string);
	constructor();
	/**
	 * Initialize the controller after the component has been constructed
	 * and the config is available
	 */
	protected childUpdated(): void;
	/**
	 * Handler for wrapper-click event from InputWrapper component
	 * This is still needed for hosted iframe inputs
	 */
	private handleWrapperClick;
	/**
	 * Get the error code from the hosted input controller when the input is submitted or touched
	 *
	 * Can be used instead of the error returned by the `validate()` method since internally `primer-sdk-web`
	 * uses the same logic to compute the error code
	 *
	 * @returns {string|null}
	 */
	getError(): string | null;
	/**
	 * Common rendering logic for all card input components
	 */
	protected renderInput(): typeof nothing | TemplateResult<1>;
}
/**
 * Card number input component with dynamic card network detection and selection
 */
declare class InputCardNumberComponent extends AbstractCardInputComponent {
	static styles: CSSResult[];
	/**
	 * Configuration for this input component
	 */
	protected readonly config: InputComponentConfig;
	constructor();
	/**
	 * Handle network selection from the network selector component
	 */
	private handleNetworkSelected;
	/**
	 * Override the renderInput method to include the network selector
	 */
	protected renderInput(): typeof nothing | TemplateResult<1>;
	render(): typeof nothing | TemplateResult<1>;
}
declare global {
	interface HTMLElementTagNameMap {
		"primer-input-card-number": InputCardNumberComponent;
	}
}
declare class InputCvvComponent extends AbstractCardInputComponent {
	static styles: CSSResult[];
	protected readonly config: InputComponentConfig;
	constructor();
	render(): typeof nothing | TemplateResult<1>;
}
declare global {
	interface HTMLElementTagNameMap {
		"primer-input-cvv": InputCvvComponent;
	}
}
declare class InputCardExpiryComponent extends AbstractCardInputComponent {
	static styles: CSSResult[];
	protected readonly config: InputComponentConfig;
	constructor();
	render(): typeof nothing | TemplateResult<1>;
}
declare global {
	interface HTMLElementTagNameMap {
		"primer-input-card-expiry": InputCardExpiryComponent;
	}
}
declare class InputCardHolderNameComponent extends AbstractCardInputComponent {
	static styles: CSSResult[];
	protected readonly config: InputComponentConfig;
	constructor();
	private handleInput;
	render(): typeof nothing | TemplateResult<1>;
}
declare global {
	interface HTMLElementTagNameMap {
		"primer-input-card-holder-name": InputCardHolderNameComponent;
	}
}
/**
 * A form submit button component for card forms.
 * Provides a consistent submit button with translation support.
 */
declare class CardFormSubmitComponent extends LitElement {
	static styles: CSSResult[];
	private readonly _userAssignedProps;
	private _internalButtonText;
	/**
	 * The button text to display.
	 * Falls back to localized default if not explicitly set.
	 */
	get buttonText(): string;
	set buttonText(value: string);
	headlessInstance: HeadlessUnitilsContext;
	clientOptions: ClientOptionsContext;
	sdkState: SdkStateContext;
	/**
	 * The button variant to use.
	 * @default "primary"
	 */
	variant: string;
	/**
	 * Whether the button is disabled.
	 * @default false
	 */
	disabled: boolean;
	private handleClick;
	render(): TemplateResult<1>;
}
declare global {
	interface HTMLElementTagNameMap {
		"primer-card-form-submit": CardFormSubmitComponent;
	}
}
/**
 * Component for displaying and selecting card networks
 * Uses context directly rather than properties
 *
 * @fires network-selected - Dispatched when a network is selected with the network name as detail
 */
declare class CardNetworkSelectorComponent extends LitElement {
	static styles: CSSResult[];
	/**
	 * Card networks context from provider
	 */
	cardNetworks: CardNetworksContext;
	headlessUtils: HeadlessUnitilsContext;
	private selectedCardNetwork;
	/**
	 * Internal state to track if dropdown is open
	 */
	private isDropdownOpen;
	/**
	 * Index of the currently focused network in the dropdown
	 */
	private focusedNetworkIndex;
	/**
	 * Tracks if keyboard navigation is being used
	 */
	private isKeyboardNavigation;
	/**
	 * Reference to the dropdown button
	 */
	private buttonRef;
	/**
	 * Reference to the dropdown container
	 */
	private dropdownRef;
	/**
	 * Reference to network option elements
	 */
	private networkOptionRefs;
	/**
	 * Toggle the dropdown state
	 */
	private toggleDropdown;
	private getNetworkIconUrl;
	/**
	 * Get selectable networks from context
	 */
	private getSelectableNetworks;
	/**
	 * Get detected network from context
	 */
	private getDetectedNetwork;
	/**
	 * Get the index of the currently selected network
	 */
	private getSelectedNetworkIndex;
	/**
	 * Handle network selection
	 */
	private selectNetwork;
	/**
	 * Handle click outside to close dropdown
	 */
	private handleClickOutside;
	/**
	 * Handle mouse movement to disable keyboard navigation mode
	 */
	private handleMouseMove;
	/**
	 * Handle keydown events for keyboard navigation
	 */
	private handleKeyDown;
	/**
	 * Focus the current network option
	 */
	private focusNetworkOption;
	/**
	 * Save reference to network option element
	 */
	private setNetworkOptionRef;
	/**
	 * Attach event listener to the component for keydown events
	 * and to document for click outside and mousemove
	 */
	connectedCallback(): void;
	/**
	 * Handle document-level keydown events, but only when dropdown is open
	 * This allows keyboard navigation to continue working
	 */
	private handleDocumentKeyDown;
	/**
	 * Lifecycle: Remove all event listeners when disconnected
	 */
	disconnectedCallback(): void;
	render(): TemplateResult<1>;
}
declare global {
	interface HTMLElementTagNameMap {
		"primer-card-network-selector": CardNetworkSelectorComponent;
	}
}
declare global {
	interface HTMLElementTagNameMap {
		"primer-card-form": CardFormComponent;
	}
}
/**
 * Component for showing/hiding other payment methods when vault is present
 * Utilizes the collapsable component for smooth transitions
 */
declare class ShowOtherPaymentsComponent extends LitElement {
	static styles: CSSResult[];
	/**
	 * Consume the vault manager context to interact with vault state
	 */
	vaultManager: VaultManagerContext;
	render(): typeof nothing | TemplateResult<1>;
}
declare global {
	interface HTMLElementTagNameMap {
		"primer-show-other-payments": ShowOtherPaymentsComponent;
	}
}
/**
 * Component for rendering native payment buttons (Apple Pay, Google Pay, PayPal)
 * with proper height calculations based on design system variables.
 */
declare class NativePaymentComponent extends LitElement {
	static styles: CSSResult[];
	paymentMethod: InitializedPaymentMethod | undefined;
	paymentManagers: InitializedManagersMap;
	computedStyles: CSSStyleDeclaration | null;
	private _buttonId;
	private loadManagerTask;
	constructor();
	/**
	 * Calculates the button height based on CSS variables
	 * Mirrors the calculation used in the host styles
	 */
	private calculateButtonHeight;
	/**
	 * Creates render options with appropriate styles based on payment method type
	 */
	private createRenderOptions;
	protected updated(changedProperties: PropertyValues): void;
	render(): symbol | TemplateResult<1> | undefined;
}
declare global {
	interface HTMLElementTagNameMap {
		"primer-native-payment": NativePaymentComponent;
	}
}
declare class PrimerCheckoutCompleteComponent extends LitElement {
	render(): TemplateResult<1>;
}
declare global {
	interface HTMLElementTagNameMap {
		"primer-checkout-complete": PrimerCheckoutCompleteComponent;
	}
}
declare class PrimerCheckoutErrorComponent extends LitElement {
	sdkState: SdkStateContext;
	render(): TemplateResult<1>;
}
declare global {
	interface HTMLElementTagNameMap {
		"primer-checkout-error": PrimerCheckoutErrorComponent;
	}
}
/**
 * A container component that connects to the SDK state context
 * and displays appropriate error messages based on error state.
 *
 * This component handles both process errors (typically from backend)
 * and validation errors (typically from client-side), managing when
 * and how they are displayed based on the current SDK state.
 */
declare class ErrorMessageContainerComponent extends LitElement {
	static styles: CSSResult[];
	/**
	 * Consume the SDK state context
	 * This automatically subscribes to changes in the SDK state
	 */
	protected sdkState?: SdkStateContext;
	showProcessingErrors: boolean;
	/**
	 * Determine if an error should be shown
	 * Takes into account the current SDK state and component configuration
	 *
	 * @returns Boolean indicating whether an error should be shown
	 */
	private get shouldShowError();
	render(): typeof nothing | TemplateResult<1>;
}
declare global {
	interface HTMLElementTagNameMap {
		"primer-error-message-container": ErrorMessageContainerComponent;
	}
}
declare class PrimerMainComponent extends LitElement {
	static styles: CSSResult[];
	private hasAssignedContent;
	/**
	 * Inline slotchange event listener.
	 * Uses assignedNodes with flatten to detect if the slot has any nodes.
	 */
	private onSlotChange;
	paymentMethods: PaymentMethodsContext;
	sdkState: SdkStateContext;
	render(): TemplateResult<1>;
}
declare global {
	interface HTMLElementTagNameMap {
		"primer-main": PrimerMainComponent;
	}
}
/**
 * Main function to load the Primer SDK with all required dependencies and styles
 * @returns {Promise<void>} A promise that resolves when loading is complete
 */
export declare function loadPrimer(): Promise<void>;
declare global {
	interface HTMLElementTagNameMap {
		"primer-checkout": PrimerCheckoutComponent;
	}
}

export {
	AchPaymentComponent as AchPayment,
	ButtonComponent as Button,
	CardFormComponent as CardForm,
	CardFormSubmitComponent as CardFormSubmit,
	CardNetworkSelectorComponent as CardFormCardNetworkSelector,
	CollapsableComponent as Collapsable,
	DialogComponent as Dialog,
	DynamicPaymentComponent as DynamicPayment,
	ErrorMessageComponent as ErrorMessage,
	ErrorMessageContainerComponent as ErrorMessageContainer,
	InputCardExpiryComponent as CardFormExpiry,
	InputCardHolderNameComponent as CardFormName,
	InputCardNumberComponent as CardFormCardNumber,
	InputComponent as Input,
	InputCvvComponent as CardFormCVV,
	InputErrorComponent as CardFormError,
	InputLabelComponent as InputLabel,
	InputWrapperComponent as InputWrapper,
	NativePaymentComponent as NativePayment,
	PaymentMethodComponent as PaymentMethod,
	PortalComponent as Portal,
	PrimerCheckoutCompleteComponent as PrimerCheckoutComplete,
	PrimerCheckoutErrorComponent as PrimerCheckoutFailure,
	PrimerCheckoutStateComponent as PrimerCheckoutState,
	PrimerIconComponent as PrimerIcon,
	PrimerKlarnaComponent as PrimerKlarna,
	PrimerMainComponent as PrimerMain,
	RedirectPaymentComponent as RedirectPayment,
	ShowOtherPaymentsComponent as ShowOtherPayments,
	SpinnerComponent as Spinner,
	VaultCvvInputComponent as VaultCvvInput,
	VaultDeleteConfirmationComponent as VaultDeleteConfirmation,
	VaultEmptyStateComponent as VaultEmptyState,
	VaultErrorMessageComponent as VaultErrorMessage,
	VaultManagerComponent as VaultManager,
	VaultManagerHeaderComponent as VaultManagerHeader,
	VaultPaymentMethodItemComponent as VaultPaymentMethodItem,
	VaultPaymentSubmitComponent as VaultPaymentSubmit,
};

export {};
